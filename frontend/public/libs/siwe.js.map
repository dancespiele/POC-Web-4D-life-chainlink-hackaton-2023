{
  "version": 3,
  "sources": ["../node_modules/base64-js/index.js", "../node_modules/ieee754/index.js", "../node_modules/buffer/index.js", "../node_modules/apg-js/src/apg-lib/identifiers.js", "../node_modules/apg-js/src/apg-lib/style.js", "../node_modules/apg-js/src/apg-conv-api/transformers.js", "../node_modules/apg-js/src/apg-conv-api/converter.js", "../node_modules/apg-js/src/apg-lib/emitcss.js", "../node_modules/apg-js/src/apg-lib/utilities.js", "../node_modules/apg-js/src/apg-lib/ast.js", "../node_modules/apg-js/src/apg-lib/circular-buffer.js", "../node_modules/apg-js/src/apg-lib/parser.js", "../node_modules/apg-js/src/apg-lib/stats.js", "../node_modules/apg-js/src/apg-lib/trace.js", "../node_modules/apg-js/src/apg-lib/node-exports.js", "../node_modules/apg-js/src/apg-api/scanner-grammar.js", "../node_modules/apg-js/src/apg-api/scanner-callbacks.js", "../node_modules/apg-js/src/apg-api/scanner.js", "../node_modules/apg-js/src/apg-api/syntax-callbacks.js", "../node_modules/apg-js/src/apg-api/semantic-callbacks.js", "../node_modules/apg-js/src/apg-api/sabnf-grammar.js", "../node_modules/apg-js/src/apg-api/parser.js", "../node_modules/apg-js/src/apg-api/rule-attributes.js", "../node_modules/apg-js/src/apg-api/rule-dependencies.js", "../node_modules/apg-js/src/apg-api/attributes.js", "../node_modules/apg-js/src/apg-api/show-rules.js", "../node_modules/apg-js/src/apg-api/api.js", "../node_modules/valid-url/index.js", "../node_modules/@stablelib/random/source/browser.ts", "../node_modules/@stablelib/wipe/wipe.ts", "../node_modules/@stablelib/random/source/node.ts", "../node_modules/@stablelib/random/source/system.ts", "../node_modules/@stablelib/int/int.ts", "../node_modules/@stablelib/binary/binary.ts", "../node_modules/@stablelib/random/random.ts", "../lib/siwe.ts", "../lib/siwe-parse/abnf.ts", "../node_modules/@noble/hashes/src/_assert.ts", "../node_modules/@noble/hashes/src/_u64.ts", "../node_modules/@noble/hashes/src/crypto.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/sha3.ts", "../lib/siwe-parse/utils.ts", "../lib/client.ts", "../node_modules/ethers/src.ts/_version.ts", "../node_modules/ethers/src.ts/utils/properties.ts", "../node_modules/ethers/src.ts/utils/errors.ts", "../node_modules/ethers/src.ts/utils/data.ts", "../node_modules/ethers/src.ts/utils/maths.ts", "../node_modules/ethers/src.ts/utils/events.ts", "../node_modules/ethers/src.ts/utils/utf8.ts", "../node_modules/ethers/src.ts/abi/coders/abstract-coder.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/_sha2.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../node_modules/ethers/src.ts/crypto/keccak.ts", "../node_modules/@noble/curves/src/abstract/utils.ts", "../node_modules/@noble/curves/src/abstract/modular.ts", "../node_modules/@noble/curves/src/abstract/curve.ts", "../node_modules/@noble/curves/src/abstract/weierstrass.ts", "../node_modules/@noble/curves/src/_shortw_utils.ts", "../node_modules/@noble/curves/src/secp256k1.ts", "../node_modules/ethers/src.ts/constants/hashes.ts", "../node_modules/ethers/src.ts/constants/strings.ts", "../node_modules/ethers/src.ts/crypto/signature.ts", "../node_modules/ethers/src.ts/crypto/signing-key.ts", "../node_modules/ethers/src.ts/address/address.ts", "../node_modules/ethers/src.ts/address/checks.ts", "../node_modules/ethers/src.ts/abi/typed.ts", "../node_modules/ethers/src.ts/abi/coders/address.ts", "../node_modules/ethers/src.ts/abi/coders/anonymous.ts", "../node_modules/ethers/src.ts/abi/coders/array.ts", "../node_modules/ethers/src.ts/abi/coders/boolean.ts", "../node_modules/ethers/src.ts/abi/coders/bytes.ts", "../node_modules/ethers/src.ts/abi/coders/fixed-bytes.ts", "../node_modules/ethers/src.ts/abi/coders/null.ts", "../node_modules/ethers/src.ts/abi/coders/number.ts", "../node_modules/ethers/src.ts/abi/coders/string.ts", "../node_modules/ethers/src.ts/abi/coders/tuple.ts", "../node_modules/ethers/src.ts/hash/id.ts", "../node_modules/ethers/src.ts/transaction/accesslist.ts", "../node_modules/ethers/src.ts/transaction/address.ts", "../node_modules/ethers/src.ts/hash/message.ts", "../node_modules/ethers/src.ts/abi/fragments.ts", "../node_modules/ethers/src.ts/abi/abi-coder.ts", "../node_modules/ethers/src.ts/abi/interface.ts", "../node_modules/ethers/src.ts/providers/provider.ts", "../node_modules/ethers/src.ts/contract/wrappers.ts", "../node_modules/ethers/src.ts/contract/contract.ts", "../lib/ethersCompat.ts", "../lib/types.ts", "../lib/utils.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n", "module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n", "/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst { Buffer } = require('buffer');\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return exports.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return exports.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst { Buffer } = require('buffer');\n\nconst trans = require('./transformers');\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n  return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n", "// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n", "/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = require('./style');\nconst converter = require('../apg-conv-api/converter');\nconst emitCss = require('./emitcss');\nconst id = require('./identifiers');\n\nconst thisFileName = 'utilities.js: ';\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${exports.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${exports.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += exports.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n", "/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n", "/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n  const style = require('./style');\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n", "/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = require('./utilities');\n  const style = require('./style');\n  const circular = new (require('./circular-buffer'))();\n  const id = require('./identifiers');\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: require('./ast'),\n  circular: require('./circular-buffer'),\n  ids: require('./identifiers'),\n  parser: require('./parser'),\n  stats: require('./stats'),\n  trace: require('./trace'),\n  utils: require('./utilities'),\n  emitcss: require('./emitcss'),\n  style: require('./style'),\n};\n", "// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'file', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'line', lower: 'line', index: 1, isBkr: false};\n  this.rules[2] = {name: 'line-text', lower: 'line-text', index: 2, isBkr: false};\n  this.rules[3] = {name: 'last-line', lower: 'last-line', index: 3, isBkr: false};\n  this.rules[4] = {name: 'valid', lower: 'valid', index: 4, isBkr: false};\n  this.rules[5] = {name: 'invalid', lower: 'invalid', index: 5, isBkr: false};\n  this.rules[6] = {name: 'end', lower: 'end', index: 6, isBkr: false};\n  this.rules[7] = {name: 'CRLF', lower: 'crlf', index: 7, isBkr: false};\n  this.rules[8] = {name: 'LF', lower: 'lf', index: 8, isBkr: false};\n  this.rules[9] = {name: 'CR', lower: 'cr', index: 9, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[0].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(line)\n  this.rules[0].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[0].opcodes[4] = {type: 4, index: 3};// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[1].opcodes[1] = {type: 4, index: 2};// RNM(line-text)\n  this.rules[1].opcodes[2] = {type: 4, index: 6};// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[2].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[2].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[2].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[3].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[3].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[3].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[4].opcodes[2] = {type: 6, string: [9]};// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[5].opcodes[1] = {type: 5, min: 0, max: 8};// TRG\n  this.rules[5].opcodes[2] = {type: 5, min: 11, max: 12};// TRG\n  this.rules[5].opcodes[3] = {type: 5, min: 14, max: 31};// TRG\n  this.rules[5].opcodes[4] = {type: 5, min: 127, max: 4294967295};// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[6].opcodes[1] = {type: 4, index: 7};// RNM(CRLF)\n  this.rules[6].opcodes[2] = {type: 4, index: 8};// RNM(LF)\n  this.rules[6].opcodes[3] = {type: 4, index: 9};// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 6, string: [13,10]};// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 6, string: [10]};// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 6, string: [13]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = require('../apg-lib/identifiers');\nconst utils = require('../apg-lib/utilities');\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = require('../apg-lib/node-exports');\n  const grammar = new (require('./scanner-grammar'))();\n  const { callbacks } = require('./scanner-callbacks');\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n", "/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = require('../apg-lib/node-exports');\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = require('../apg-lib/node-exports');\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n", "// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'File', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false};\n  this.rules[2] = {name: 'Rule', lower: 'rule', index: 2, isBkr: false};\n  this.rules[3] = {name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false};\n  this.rules[4] = {name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false};\n  this.rules[5] = {name: 'RuleName', lower: 'rulename', index: 5, isBkr: false};\n  this.rules[6] = {name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false};\n  this.rules[7] = {name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false};\n  this.rules[8] = {name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false};\n  this.rules[9] = {name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false};\n  this.rules[10] = {name: 'Defined', lower: 'defined', index: 10, isBkr: false};\n  this.rules[11] = {name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false};\n  this.rules[12] = {name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false};\n  this.rules[13] = {name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false};\n  this.rules[14] = {name: 'Alternation', lower: 'alternation', index: 14, isBkr: false};\n  this.rules[15] = {name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false};\n  this.rules[16] = {name: 'Repetition', lower: 'repetition', index: 16, isBkr: false};\n  this.rules[17] = {name: 'Modifier', lower: 'modifier', index: 17, isBkr: false};\n  this.rules[18] = {name: 'Predicate', lower: 'predicate', index: 18, isBkr: false};\n  this.rules[19] = {name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false};\n  this.rules[20] = {name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false};\n  this.rules[21] = {name: 'Group', lower: 'group', index: 21, isBkr: false};\n  this.rules[22] = {name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false};\n  this.rules[23] = {name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false};\n  this.rules[24] = {name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false};\n  this.rules[25] = {name: 'Option', lower: 'option', index: 25, isBkr: false};\n  this.rules[26] = {name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false};\n  this.rules[27] = {name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false};\n  this.rules[28] = {name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false};\n  this.rules[29] = {name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false};\n  this.rules[30] = {name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false};\n  this.rules[31] = {name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false};\n  this.rules[32] = {name: 'cs', lower: 'cs', index: 32, isBkr: false};\n  this.rules[33] = {name: 'ci', lower: 'ci', index: 33, isBkr: false};\n  this.rules[34] = {name: 'um', lower: 'um', index: 34, isBkr: false};\n  this.rules[35] = {name: 'pm', lower: 'pm', index: 35, isBkr: false};\n  this.rules[36] = {name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false};\n  this.rules[37] = {name: 'rname', lower: 'rname', index: 37, isBkr: false};\n  this.rules[38] = {name: 'uname', lower: 'uname', index: 38, isBkr: false};\n  this.rules[39] = {name: 'ename', lower: 'ename', index: 39, isBkr: false};\n  this.rules[40] = {name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false};\n  this.rules[41] = {name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false};\n  this.rules[42] = {name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false};\n  this.rules[43] = {name: 'RepOp', lower: 'repop', index: 43, isBkr: false};\n  this.rules[44] = {name: 'AltOp', lower: 'altop', index: 44, isBkr: false};\n  this.rules[45] = {name: 'CatOp', lower: 'catop', index: 45, isBkr: false};\n  this.rules[46] = {name: 'StarOp', lower: 'starop', index: 46, isBkr: false};\n  this.rules[47] = {name: 'AndOp', lower: 'andop', index: 47, isBkr: false};\n  this.rules[48] = {name: 'NotOp', lower: 'notop', index: 48, isBkr: false};\n  this.rules[49] = {name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false};\n  this.rules[50] = {name: 'BknOp', lower: 'bknop', index: 50, isBkr: false};\n  this.rules[51] = {name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false};\n  this.rules[52] = {name: 'AenOp', lower: 'aenop', index: 52, isBkr: false};\n  this.rules[53] = {name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false};\n  this.rules[54] = {name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false};\n  this.rules[55] = {name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false};\n  this.rules[56] = {name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false};\n  this.rules[57] = {name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false};\n  this.rules[58] = {name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false};\n  this.rules[59] = {name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false};\n  this.rules[60] = {name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false};\n  this.rules[61] = {name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false};\n  this.rules[62] = {name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false};\n  this.rules[63] = {name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false};\n  this.rules[64] = {name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false};\n  this.rules[65] = {name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false};\n  this.rules[66] = {name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false};\n  this.rules[67] = {name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false};\n  this.rules[68] = {name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false};\n  this.rules[69] = {name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false};\n  this.rules[70] = {name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false};\n  this.rules[71] = {name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false};\n  this.rules[72] = {name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false};\n  this.rules[73] = {name: 'dString', lower: 'dstring', index: 73, isBkr: false};\n  this.rules[74] = {name: 'xString', lower: 'xstring', index: 74, isBkr: false};\n  this.rules[75] = {name: 'bString', lower: 'bstring', index: 75, isBkr: false};\n  this.rules[76] = {name: 'Dec', lower: 'dec', index: 76, isBkr: false};\n  this.rules[77] = {name: 'Hex', lower: 'hex', index: 77, isBkr: false};\n  this.rules[78] = {name: 'Bin', lower: 'bin', index: 78, isBkr: false};\n  this.rules[79] = {name: 'dmin', lower: 'dmin', index: 79, isBkr: false};\n  this.rules[80] = {name: 'dmax', lower: 'dmax', index: 80, isBkr: false};\n  this.rules[81] = {name: 'bmin', lower: 'bmin', index: 81, isBkr: false};\n  this.rules[82] = {name: 'bmax', lower: 'bmax', index: 82, isBkr: false};\n  this.rules[83] = {name: 'xmin', lower: 'xmin', index: 83, isBkr: false};\n  this.rules[84] = {name: 'xmax', lower: 'xmax', index: 84, isBkr: false};\n  this.rules[85] = {name: 'dnum', lower: 'dnum', index: 85, isBkr: false};\n  this.rules[86] = {name: 'bnum', lower: 'bnum', index: 86, isBkr: false};\n  this.rules[87] = {name: 'xnum', lower: 'xnum', index: 87, isBkr: false};\n  this.rules[88] = {name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false};\n  this.rules[89] = {name: 'owsp', lower: 'owsp', index: 89, isBkr: false};\n  this.rules[90] = {name: 'wsp', lower: 'wsp', index: 90, isBkr: false};\n  this.rules[91] = {name: 'space', lower: 'space', index: 91, isBkr: false};\n  this.rules[92] = {name: 'comment', lower: 'comment', index: 92, isBkr: false};\n  this.rules[93] = {name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false};\n  this.rules[94] = {name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(BlankLine)\n  this.rules[0].opcodes[3] = {type: 4, index: 2};// RNM(Rule)\n  this.rules[0].opcodes[4] = {type: 4, index: 12};// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,5,7]};// CAT\n  this.rules[1].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[1].opcodes[2] = {type: 1, children: [3,4]};// ALT\n  this.rules[1].opcodes[3] = {type: 6, string: [32]};// TBS\n  this.rules[1].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[1].opcodes[5] = {type: 3, min: 0, max: 1};// REP\n  this.rules[1].opcodes[6] = {type: 4, index: 92};// RNM(comment)\n  this.rules[1].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[2].opcodes[1] = {type: 4, index: 3};// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[3] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[2].opcodes[4] = {type: 1, children: [5,8]};// ALT\n  this.rules[2].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[2].opcodes[6] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n  this.rules[2].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[2].opcodes[9] = {type: 4, index: 13};// RNM(LineEndError)\n  this.rules[2].opcodes[10] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[3].opcodes[1] = {type: 4, index: 4};// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[3].opcodes[3] = {type: 4, index: 7};// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 4, index: 5};// RNM(RuleName)\n  this.rules[4].opcodes[2] = {type: 4, index: 6};// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[6].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[6].opcodes[2] = {type: 5, min: 33, max: 60};// TRG\n  this.rules[6].opcodes[3] = {type: 5, min: 62, max: 126};// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[7].opcodes[1] = {type: 4, index: 9};// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = {type: 4, index: 8};// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 3, min: 1, max: 2};// REP\n  this.rules[8].opcodes[1] = {type: 5, min: 33, max: 126};// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[9].opcodes[1] = {type: 4, index: 11};// RNM(IncAlt)\n  this.rules[9].opcodes[2] = {type: 4, index: 10};// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = {type: 6, string: [61]};// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = {type: 6, string: [61,47]};// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = {type: 2, children: [1,6]};// CAT\n  this.rules[12].opcodes[1] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[12].opcodes[2] = {type: 1, children: [3,4,5]};// ALT\n  this.rules[12].opcodes[3] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[12].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[12].opcodes[5] = {type: 4, index: 94};// RNM(LineContinue)\n  this.rules[12].opcodes[6] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[13].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[13].opcodes[2] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[13].opcodes[3] = {type: 6, string: [9]};// TBS\n  this.rules[13].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[14].opcodes[1] = {type: 4, index: 15};// RNM(Concatenation)\n  this.rules[14].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[14].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[14].opcodes[4] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[14].opcodes[5] = {type: 4, index: 44};// RNM(AltOp)\n  this.rules[14].opcodes[6] = {type: 4, index: 15};// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[15].opcodes[1] = {type: 4, index: 16};// RNM(Repetition)\n  this.rules[15].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[15].opcodes[3] = {type: 2, children: [4,5]};// CAT\n  this.rules[15].opcodes[4] = {type: 4, index: 45};// RNM(CatOp)\n  this.rules[15].opcodes[5] = {type: 4, index: 16};// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[16].opcodes[1] = {type: 3, min: 0, max: 1};// REP\n  this.rules[16].opcodes[2] = {type: 4, index: 17};// RNM(Modifier)\n  this.rules[16].opcodes[3] = {type: 1, children: [4,5,6,7]};// ALT\n  this.rules[16].opcodes[4] = {type: 4, index: 21};// RNM(Group)\n  this.rules[16].opcodes[5] = {type: 4, index: 25};// RNM(Option)\n  this.rules[16].opcodes[6] = {type: 4, index: 19};// RNM(BasicElement)\n  this.rules[16].opcodes[7] = {type: 4, index: 20};// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = {type: 1, children: [1,5]};// ALT\n  this.rules[17].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[17].opcodes[2] = {type: 4, index: 18};// RNM(Predicate)\n  this.rules[17].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[17].opcodes[4] = {type: 4, index: 43};// RNM(RepOp)\n  this.rules[17].opcodes[5] = {type: 4, index: 43};// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[18].opcodes[1] = {type: 4, index: 49};// RNM(BkaOp)\n  this.rules[18].opcodes[2] = {type: 4, index: 50};// RNM(BknOp)\n  this.rules[18].opcodes[3] = {type: 4, index: 47};// RNM(AndOp)\n  this.rules[18].opcodes[4] = {type: 4, index: 48};// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = {type: 1, children: [1,2,3,4,5,6,7,8,9,10]};// ALT\n  this.rules[19].opcodes[1] = {type: 4, index: 40};// RNM(UdtOp)\n  this.rules[19].opcodes[2] = {type: 4, index: 29};// RNM(RnmOp)\n  this.rules[19].opcodes[3] = {type: 4, index: 53};// RNM(TrgOp)\n  this.rules[19].opcodes[4] = {type: 4, index: 54};// RNM(TbsOp)\n  this.rules[19].opcodes[5] = {type: 4, index: 55};// RNM(TlsOp)\n  this.rules[19].opcodes[6] = {type: 4, index: 61};// RNM(ClsOp)\n  this.rules[19].opcodes[7] = {type: 4, index: 30};// RNM(BkrOp)\n  this.rules[19].opcodes[8] = {type: 4, index: 51};// RNM(AbgOp)\n  this.rules[19].opcodes[9] = {type: 4, index: 52};// RNM(AenOp)\n  this.rules[19].opcodes[10] = {type: 4, index: 65};// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[20].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[20].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[20].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[20].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[20].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[21].opcodes[1] = {type: 4, index: 23};// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[21].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[21].opcodes[4] = {type: 4, index: 24};// RNM(GroupClose)\n  this.rules[21].opcodes[5] = {type: 4, index: 22};// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[22].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[22].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[22].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[22].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[22].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[23].opcodes[1] = {type: 6, string: [40]};// TBS\n  this.rules[23].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[24].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[24].opcodes[2] = {type: 6, string: [41]};// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[25].opcodes[1] = {type: 4, index: 27};// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[25].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[25].opcodes[4] = {type: 4, index: 28};// RNM(OptionClose)\n  this.rules[25].opcodes[5] = {type: 4, index: 26};// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[26].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[26].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[26].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[26].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[26].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[27].opcodes[1] = {type: 6, string: [91]};// TBS\n  this.rules[27].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[28].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[28].opcodes[2] = {type: 6, string: [93]};// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = {type: 2, children: [1,2,4]};// CAT\n  this.rules[30].opcodes[1] = {type: 6, string: [92]};// TBS\n  this.rules[30].opcodes[2] = {type: 3, min: 0, max: 1};// REP\n  this.rules[30].opcodes[3] = {type: 4, index: 31};// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = {type: 4, index: 36};// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = {type: 1, children: [1,7,13,19]};// ALT\n  this.rules[31].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[31].opcodes[2] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[4] = {type: 1, children: [5,6]};// ALT\n  this.rules[31].opcodes[5] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[6] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[31].opcodes[8] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[9] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[10] = {type: 1, children: [11,12]};// ALT\n  this.rules[31].opcodes[11] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[12] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[13] = {type: 2, children: [14,15]};// CAT\n  this.rules[31].opcodes[14] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[15] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[16] = {type: 1, children: [17,18]};// ALT\n  this.rules[31].opcodes[17] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[18] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[19] = {type: 2, children: [20,21]};// CAT\n  this.rules[31].opcodes[20] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[21] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[22] = {type: 1, children: [23,24]};// ALT\n  this.rules[31].opcodes[23] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[24] = {type: 4, index: 33};// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = {type: 6, string: [37,115]};// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = {type: 6, string: [37,105]};// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = {type: 6, string: [37,117]};// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = {type: 6, string: [37,112]};// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[36].opcodes[1] = {type: 4, index: 38};// RNM(uname)\n  this.rules[36].opcodes[2] = {type: 4, index: 39};// RNM(ename)\n  this.rules[36].opcodes[3] = {type: 4, index: 37};// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[38].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[38].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[39].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[39].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[40].opcodes[1] = {type: 4, index: 42};// RNM(udt-empty)\n  this.rules[40].opcodes[2] = {type: 4, index: 41};// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[41].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[41].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[42].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[42].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = {type: 1, children: [1,5,8,11,12]};// ALT\n  this.rules[43].opcodes[1] = {type: 2, children: [2,3,4]};// CAT\n  this.rules[43].opcodes[2] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[3] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[4] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[43].opcodes[6] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[7] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[43].opcodes[9] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[10] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[11] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[12] = {type: 4, index: 70};// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[44].opcodes[1] = {type: 6, string: [47]};// TBS\n  this.rules[44].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = {type: 4, index: 90};// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = {type: 6, string: [42]};// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = {type: 6, string: [38]};// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = {type: 6, string: [33]};// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = {type: 6, string: [38,38]};// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = {type: 6, string: [33,33]};// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = {type: 6, string: [37,94]};// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = {type: 6, string: [37,36]};// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[53].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[53].opcodes[2] = {type: 1, children: [3,8,13]};// ALT\n  this.rules[53].opcodes[3] = {type: 2, children: [4,5,6,7]};// CAT\n  this.rules[53].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[53].opcodes[5] = {type: 4, index: 79};// RNM(dmin)\n  this.rules[53].opcodes[6] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[7] = {type: 4, index: 80};// RNM(dmax)\n  this.rules[53].opcodes[8] = {type: 2, children: [9,10,11,12]};// CAT\n  this.rules[53].opcodes[9] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[53].opcodes[10] = {type: 4, index: 83};// RNM(xmin)\n  this.rules[53].opcodes[11] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[12] = {type: 4, index: 84};// RNM(xmax)\n  this.rules[53].opcodes[13] = {type: 2, children: [14,15,16,17]};// CAT\n  this.rules[53].opcodes[14] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[53].opcodes[15] = {type: 4, index: 81};// RNM(bmin)\n  this.rules[53].opcodes[16] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[17] = {type: 4, index: 82};// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[54].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[54].opcodes[2] = {type: 1, children: [3,10,17]};// ALT\n  this.rules[54].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[54].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[54].opcodes[5] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[6] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[54].opcodes[8] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[9] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[10] = {type: 2, children: [11,12,13]};// CAT\n  this.rules[54].opcodes[11] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[54].opcodes[12] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[13] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[14] = {type: 2, children: [15,16]};// CAT\n  this.rules[54].opcodes[15] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[16] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[17] = {type: 2, children: [18,19,20]};// CAT\n  this.rules[54].opcodes[18] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[54].opcodes[19] = {type: 4, index: 75};// RNM(bString)\n  this.rules[54].opcodes[20] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[21] = {type: 2, children: [22,23]};// CAT\n  this.rules[54].opcodes[22] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[23] = {type: 4, index: 75};// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[55].opcodes[1] = {type: 4, index: 56};// RNM(TlsCase)\n  this.rules[55].opcodes[2] = {type: 4, index: 57};// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = {type: 4, index: 59};// RNM(TlsString)\n  this.rules[55].opcodes[4] = {type: 4, index: 58};// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = {type: 3, min: 0, max: 1};// REP\n  this.rules[56].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[56].opcodes[2] = {type: 7, string: [37,105]};// TLS\n  this.rules[56].opcodes[3] = {type: 7, string: [37,115]};// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[59].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[59].opcodes[2] = {type: 5, min: 32, max: 33};// TRG\n  this.rules[59].opcodes[3] = {type: 5, min: 35, max: 126};// TRG\n  this.rules[59].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = {type: 6, string: [9]};// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[61].opcodes[1] = {type: 4, index: 62};// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = {type: 4, index: 64};// RNM(ClsString)\n  this.rules[61].opcodes[3] = {type: 4, index: 63};// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[64].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[64].opcodes[2] = {type: 5, min: 32, max: 38};// TRG\n  this.rules[64].opcodes[3] = {type: 5, min: 40, max: 126};// TRG\n  this.rules[64].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[65].opcodes[1] = {type: 4, index: 66};// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = {type: 4, index: 67};// RNM(ProsValString)\n  this.rules[65].opcodes[3] = {type: 4, index: 68};// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = {type: 6, string: [60]};// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[67].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[67].opcodes[2] = {type: 5, min: 32, max: 61};// TRG\n  this.rules[67].opcodes[3] = {type: 5, min: 63, max: 126};// TRG\n  this.rules[67].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = {type: 6, string: [62]};// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[72].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[76].opcodes[1] = {type: 6, string: [68]};// TBS\n  this.rules[76].opcodes[2] = {type: 6, string: [100]};// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[77].opcodes[1] = {type: 6, string: [88]};// TBS\n  this.rules[77].opcodes[2] = {type: 6, string: [120]};// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[78].opcodes[1] = {type: 6, string: [66]};// TBS\n  this.rules[78].opcodes[2] = {type: 6, string: [98]};// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[85].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[86].opcodes[1] = {type: 5, min: 48, max: 49};// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[87].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[87].opcodes[2] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[87].opcodes[3] = {type: 5, min: 65, max: 70};// TRG\n  this.rules[87].opcodes[4] = {type: 5, min: 97, max: 102};// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = {type: 2, children: [1,4]};// CAT\n  this.rules[88].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[88].opcodes[2] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[3] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[4] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[88].opcodes[5] = {type: 1, children: [6,7,8,9]};// ALT\n  this.rules[88].opcodes[6] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[7] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[8] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[88].opcodes[9] = {type: 6, string: [45]};// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[89].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[90].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[91].opcodes[1] = {type: 6, string: [32]};// TBS\n  this.rules[91].opcodes[2] = {type: 6, string: [9]};// TBS\n  this.rules[91].opcodes[3] = {type: 4, index: 92};// RNM(comment)\n  this.rules[91].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[92].opcodes[1] = {type: 6, string: [59]};// TBS\n  this.rules[92].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[92].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[92].opcodes[4] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[92].opcodes[5] = {type: 6, string: [9]};// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[93].opcodes[1] = {type: 6, string: [13,10]};// TBS\n  this.rules[93].opcodes[2] = {type: 6, string: [10]};// TBS\n  this.rules[93].opcodes[3] = {type: 6, string: [13]};// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = {type: 2, children: [1,5]};// CAT\n  this.rules[94].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[94].opcodes[2] = {type: 6, string: [13,10]};// TBS\n  this.rules[94].opcodes[3] = {type: 6, string: [10]};// TBS\n  this.rules[94].opcodes[4] = {type: 6, string: [13]};// TBS\n  this.rules[94].opcodes[5] = {type: 1, children: [6,7]};// ALT\n  this.rules[94].opcodes[6] = {type: 6, string: [32]};// TBS\n  this.rules[94].opcodes[7] = {type: 6, string: [9]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = require('../apg-lib/node-exports');\n  const id = ApgLib.ids;\n  const syn = new (require('./syntax-callbacks'))();\n  const sem = new (require('./semantic-callbacks'))();\n  const sabnfGrammar = new (require('./sabnf-grammar'))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, name) {\n    let source = '';\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    let funcname = 'module.exports';\n    if (name && typeof name === 'string') {\n      funcname = `let ${name}`;\n    }\n    source += '// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    source += `${funcname} = function grammar(){\\n`;\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    source += `  //        BKA = ${bka}\\n`;\n    source += `  //        BKN = ${bkn}\\n`;\n    source += `  //        BKR = ${bkr}\\n`;\n    source += `  //        ABG = ${abg}\\n`;\n    source += `  //        AEN = ${aen}\\n`;\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n    source += \"  this.grammarObject = 'grammarObject';\\n\";\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = {name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += '};\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = {name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += '};\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${\n              rules[op.index].name\n            })\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${\n              op.index\n            }};// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = require('../apg-lib/identifiers');\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = require('../apg-lib/identifiers');\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n", "/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are \u201Caggregate\u201D attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite \u2013 always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = require('../apg-lib/identifiers');\n  const { ruleAttributes, showAttributes, showAttributeErrors } = require('./rule-attributes');\n  const { ruleDependencies, showRuleDependencies } = require('./rule-dependencies');\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n", "/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const { Buffer } = require('buffer');\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = require('../apg-lib/node-exports');\n  const converter = require('../apg-conv-api/converter');\n  const scanner = require('./scanner');\n  const parser = new (require('./parser'))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = require('./attributes');\n  const showRules = require('./show-rules');\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(name) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n", "(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\n\nconst QUOTA = 65536;\n\nexport class BrowserRandomSource implements RandomSource {\n    isAvailable = false;\n    isInstantiated = false;\n\n    private _crypto?: { getRandomValues: typeof window.crypto.getRandomValues };\n\n    constructor() {\n        const browserCrypto = typeof self !== 'undefined'\n            ? (self.crypto || (self as { msCrypto?: any }).msCrypto) // IE11 has msCrypto\n            : null;\n\n        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {\n            this._crypto = browserCrypto;\n            this.isAvailable = true;\n            this.isInstantiated = true;\n        }\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Browser random byte generator is not available.\");\n        }\n        const out = new Uint8Array(length);\n        for (let i = 0; i < out.length; i += QUOTA) {\n            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));\n        }\n        return out;\n    }\n}\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package wipe implements functions for zeroing arrays.\n */\n\nexport type NumericArray = number[] | Uint8Array | Int8Array | Uint16Array\n    | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;\n\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nexport function wipe(array: NumericArray): NumericArray {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (let i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\nimport { wipe } from \"@stablelib/wipe\";\n\ndeclare function require(name: string): any;\n\nexport class NodeRandomSource implements RandomSource {\n    isAvailable = false;\n    isInstantiated = false;\n\n    private _crypto: { randomBytes(n: number): Uint8Array } | undefined;\n\n    constructor() {\n        if (typeof require !== \"undefined\") {\n            const nodeCrypto = require(\"crypto\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n\n        // Get random bytes (result is Buffer).\n        let buffer = this._crypto.randomBytes(length);\n\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n\n        // Allocate output array.\n        const out = new Uint8Array(length);\n\n        // Copy bytes from buffer to output.\n        for (let i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n\n        // Cleanup.\n        wipe(buffer);\n\n        return out;\n    }\n}\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\nimport { BrowserRandomSource } from \"./browser\";\nimport { NodeRandomSource } from \"./node\";\n\nexport class SystemRandomSource implements RandomSource {\n    isAvailable = false;\n    name = \"\";\n    private _source: RandomSource;\n\n    constructor() {\n        // Try browser.\n        this._source = new BrowserRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Browser\";\n            return;\n        }\n\n        // If no browser source, try Node.\n        this._source = new NodeRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Node\";\n            return;\n        }\n\n        // No sources, we're out of options.\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable) {\n            throw new Error(\"System random byte generator is not available.\");\n        }\n        return this._source.randomBytes(length);\n    }\n}\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package int provides helper functions for integerss.\n */\n\n// Shim using 16-bit pieces.\nfunction imulShim(a: number, b: number): number {\n    const ah = (a >>> 16) & 0xffff, al = a & 0xffff;\n    const bh = (b >>> 16) & 0xffff, bl = b & 0xffff;\n    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}\n\n/** 32-bit integer multiplication.  */\n// Use system Math.imul if available, otherwise use our shim.\nexport const mul = (Math as { imul?(a: number, b: number): number }).imul || imulShim;\n\n/** 32-bit integer addition.  */\nexport function add(a: number, b: number): number {\n    return (a + b) | 0;\n}\n\n/**  32-bit integer subtraction.  */\nexport function sub(a: number, b: number): number {\n    return (a - b) | 0;\n}\n\n/** 32-bit integer left rotation */\nexport function rotl(x: number, n: number): number {\n    return x << n | x >>> (32 - n);\n}\n\n/** 32-bit integer left rotation */\nexport function rotr(x: number, n: number): number {\n    return x << (32 - n) | x >>> n;\n}\n\nfunction isIntegerShim(n: number): boolean {\n    return typeof n === \"number\" && isFinite(n) && Math.floor(n) === n;\n}\n\n/**\n * Returns true if the argument is an integer number.\n *\n * In ES2015, Number.isInteger.\n */\nexport const isInteger = (Number as { isInteger?(n: number): boolean }).isInteger || isIntegerShim;\n\n/**\n *  Math.pow(2, 53) - 1\n *\n *  In ES2015 Number.MAX_SAFE_INTEGER.\n */\nexport const MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Returns true if the argument is a safe integer number\n * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)\n *\n * In ES2015, Number.isSafeInteger.\n */\nexport const isSafeInteger = (n: number): boolean =>\n    isInteger(n) && (n >= -MAX_SAFE_INTEGER && n <= MAX_SAFE_INTEGER);\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nimport { isSafeInteger } from \"@stablelib/int\";\n\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16BE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16LE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\n\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16BE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\n\nexport const writeInt16BE = writeUint16BE;\n\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16LE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\n\nexport const writeInt16LE = writeUint16LE;\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32BE(array: Uint8Array, offset = 0): number {\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32LE(array: Uint8Array, offset = 0): number {\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\n\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\n\nexport const writeInt32BE = writeUint32BE;\n\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\n\n\nexport const writeInt32LE = writeUint32LE;\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64BE(array: Uint8Array, offset = 0): number {\n    const hi = readInt32BE(array, offset);\n    const lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64BE(array: Uint8Array, offset = 0): number {\n    const hi = readUint32BE(array, offset);\n    const lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64LE(array: Uint8Array, offset = 0): number {\n    const lo = readInt32LE(array, offset);\n    const hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64LE(array: Uint8Array, offset = 0): number {\n    const lo = readUint32LE(array, offset);\n    const hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64BE = writeUint64BE;\n\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64LE = writeUint64LE;\n\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintBE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintLE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintBE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintLE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\n\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\n\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\n\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\n\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\n", "// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package random provides functions to access system's\n * cryptographically secure random byte generator.\n */\n\nimport { RandomSource } from \"./source\";\nimport { SystemRandomSource } from \"./source/system\";\nimport { readUint32LE } from \"@stablelib/binary\";\nimport { wipe } from \"@stablelib/wipe\";\n\nexport { RandomSource } from \"./source\";\n\nexport const defaultRandomSource = new SystemRandomSource();\n\nexport function randomBytes(length: number, prng: RandomSource = defaultRandomSource): Uint8Array {\n    return prng.randomBytes(length);\n}\n\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nexport function randomUint32(prng: RandomSource = defaultRandomSource): number {\n    // Generate 4-byte random buffer.\n    const buf = randomBytes(4, prng);\n\n    // Convert bytes from buffer into a 32-bit integer.\n    // It's not important which byte order to use, since\n    // the result is random.\n    const result = readUint32LE(buf);\n\n    // Clean the buffer.\n    wipe(buf);\n\n    return result;\n}\n\n/** 62 alphanumeric characters for default charset of randomString() */\nconst ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport function randomString(\n    length: number,\n    charset = ALPHANUMERIC,\n    prng: RandomSource = defaultRandomSource\n): string {\n    if (charset.length < 2) {\n        throw new Error(\"randomString charset is too short\");\n    }\n    if (charset.length > 256) {\n        throw new Error(\"randomString charset is too long\");\n    }\n    let out = '';\n    const charsLen = charset.length;\n    const maxByte = 256 - (256 % charsLen);\n    while (length > 0) {\n        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n        for (let i = 0; i < buf.length && length > 0; i++) {\n            const randomByte = buf[i];\n            if (randomByte < maxByte) {\n                out += charset.charAt(randomByte % charsLen);\n                length--;\n            }\n        }\n        wipe(buf);\n    }\n    return out;\n}\n\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport function randomStringForEntropy(\n    bits: number,\n    charset = ALPHANUMERIC,\n    prng: RandomSource = defaultRandomSource\n): string {\n    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n    return randomString(length, charset, prng);\n}\n", "export * from './client';\nexport * from './types';\nexport * from './utils';\n", "import apgApi from \"apg-js/src/apg-api/api\";\nimport apgLib from \"apg-js/src/apg-lib/node-exports\";\nimport { isEIP55Address, parseIntegerNumber } from \"./utils\";\n\nconst GRAMMAR = `\nsign-in-with-ethereum =\n    domain %s\" wants you to sign in with your Ethereum account:\" LF\n    address LF\n    LF\n    [ statement LF ]\n    LF\n    %s\"URI: \" URI LF\n    %s\"Version: \" version LF\n    %s\"Chain ID: \" chain-id LF\n    %s\"Nonce: \" nonce LF\n    %s\"Issued At: \" issued-at\n    [ LF %s\"Expiration Time: \" expiration-time ]\n    [ LF %s\"Not Before: \" not-before ]\n    [ LF %s\"Request ID: \" request-id ]\n    [ LF %s\"Resources:\"\n    resources ]\n\ndomain = authority\n\naddress = \"0x\" 40*40HEXDIG\n    ; Must also conform to captilization\n    ; checksum encoding specified in EIP-55\n    ; where applicable (EOAs).\n\nstatement = 1*( reserved / unreserved / \" \" )\n    ; The purpose is to exclude LF (line breaks).\n\nversion = \"1\"\n\nnonce = 8*( ALPHA / DIGIT )\n\nissued-at = date-time\nexpiration-time = date-time\nnot-before = date-time\n\nrequest-id = *pchar\n\nchain-id = 1*DIGIT\n    ; See EIP-155 for valid CHAIN_IDs.\n\nresources = *( LF resource )\n\nresource = \"- \" URI\n\n; ------------------------------------------------------------------------------\n; RFC 3986\n\nURI           = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\nhier-part     = \"//\" authority path-abempty\n              / path-absolute\n              / path-rootless\n              / path-empty\n\nscheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\nauthority     = [ userinfo \"@\" ] host [ \":\" port ]\nuserinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\nhost          = IP-literal / IPv4address / reg-name\nport          = *DIGIT\n\nIP-literal    = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n\nIPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n\nIPv6address   =                            6( h16 \":\" ) ls32\n              /                       \"::\" 5( h16 \":\" ) ls32\n              / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n              / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n              / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n              / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n              / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n              / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n              / [ *6( h16 \":\" ) h16 ] \"::\"\n\nh16           = 1*4HEXDIG\nls32          = ( h16 \":\" h16 ) / IPv4address\nIPv4address   = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\ndec-octet     = DIGIT                 ; 0-9\n                 / %x31-39 DIGIT         ; 10-99\n                 / \"1\" 2DIGIT            ; 100-199\n                 / \"2\" %x30-34 DIGIT     ; 200-249\n                 / \"25\" %x30-35          ; 250-255\n\nreg-name      = *( unreserved / pct-encoded / sub-delims )\n\npath-abempty  = *( \"/\" segment )\npath-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\npath-rootless = segment-nz *( \"/\" segment )\npath-empty    = 0pchar\n\nsegment       = *pchar\nsegment-nz    = 1*pchar\n\npchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\nquery         = *( pchar / \"/\" / \"?\" )\n\nfragment      = *( pchar / \"/\" / \"?\" )\n\npct-encoded   = \"%\" HEXDIG HEXDIG\n\nunreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nreserved      = gen-delims / sub-delims\ngen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\nsub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\n; ------------------------------------------------------------------------------\n; RFC 3339\n\ndate-fullyear   = 4DIGIT\ndate-month      = 2DIGIT  ; 01-12\ndate-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                          ; month/year\ntime-hour       = 2DIGIT  ; 00-23\ntime-minute     = 2DIGIT  ; 00-59\ntime-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                          ; rules\ntime-secfrac    = \".\" 1*DIGIT\ntime-numoffset  = (\"+\" / \"-\") time-hour \":\" time-minute\ntime-offset     = \"Z\" / time-numoffset\n\npartial-time    = time-hour \":\" time-minute \":\" time-second\n                  [time-secfrac]\nfull-date       = date-fullyear \"-\" date-month \"-\" date-mday\nfull-time       = partial-time time-offset\n\ndate-time       = full-date \"T\" full-time\n\n; ------------------------------------------------------------------------------\n; RFC 5234\n\nALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\nLF             =  %x0A\n                  ; linefeed\nDIGIT          =  %x30-39\n                  ; 0-9\nHEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n`;\n\nclass GrammarApi {\n\tstatic grammarObj = this.generateApi();\n\n\tstatic generateApi() {\n\t\tconst api = new apgApi(GRAMMAR);\n\t\tapi.generate();\n\t\tif (api.errors.length) {\n\t\t\tconsole.error(api.errorsToAscii());\n\t\t\tconsole.error(api.linesToAscii());\n\t\t\tconsole.log(api.displayAttributeErrors());\n\t\t\tthrow new Error(`ABNF grammar has errors`);\n\t\t}\n\t\treturn api.toObject();\n\t}\n}\n\nexport class ParsedMessage {\n\tdomain: string;\n\taddress: string;\n\tstatement: string | null;\n\turi: string;\n\tversion: string;\n\tchainId: number;\n\tnonce: string;\n\tissuedAt: string;\n\texpirationTime: string | null;\n\tnotBefore: string | null;\n\trequestId: string | null;\n\tresources: Array<string> | null;\n\n\tconstructor(msg: string) {\n\t\tconst parser = new apgLib.parser();\n\t\tparser.ast = new apgLib.ast();\n\t\tconst id = apgLib.ids;\n\n\t\tconst domain = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.domain = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.domain = domain;\n\t\tconst address = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.address = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.address = address;\n\n\t\tconst statement = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.statement = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.statement = statement;\n\t\tconst uri = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tif (!data.uri) {\n\t\t\t\t\tdata.uri = apgLib.utils.charsToString(\n\t\t\t\t\t\tchars,\n\t\t\t\t\t\tphraseIndex,\n\t\t\t\t\t\tphraseLength\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.uri = uri;\n\t\tconst version = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.version = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.version = version;\n\t\tconst chainId = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.chainId = parseIntegerNumber(\n\t\t\t\t\tapgLib.utils.charsToString(chars, phraseIndex, phraseLength)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks[\"chain-id\"] = chainId;\n\t\tconst nonce = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.nonce = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.nonce = nonce;\n\t\tconst issuedAt = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.issuedAt = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks[\"issued-at\"] = issuedAt;\n\t\tconst expirationTime = function (\n\t\t\tstate,\n\t\t\tchars,\n\t\t\tphraseIndex,\n\t\t\tphraseLength,\n\t\t\tdata\n\t\t) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.expirationTime = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks[\"expiration-time\"] = expirationTime;\n\t\tconst notBefore = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.notBefore = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks[\"not-before\"] = notBefore;\n\t\tconst requestId = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.requestId = apgLib.utils.charsToString(\n\t\t\t\t\tchars,\n\t\t\t\t\tphraseIndex,\n\t\t\t\t\tphraseLength\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks[\"request-id\"] = requestId;\n\t\tconst resources = function (state, chars, phraseIndex, phraseLength, data) {\n\t\t\tconst ret = id.SEM_OK;\n\t\t\tif (state === id.SEM_PRE) {\n\t\t\t\tdata.resources = apgLib.utils\n\t\t\t\t\t.charsToString(chars, phraseIndex, phraseLength)\n\t\t\t\t\t.slice(3)\n\t\t\t\t\t.split(\"\\n- \");\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tparser.ast.callbacks.resources = resources;\n\n\t\tconst result = parser.parse(GrammarApi.grammarObj, \"sign-in-with-ethereum\", msg);\n\t\tif (!result.success) {\n\t\t\tthrow new Error(`Invalid message: ${JSON.stringify(result)}`);\n\t\t}\n\t\tconst elements = {};\n\t\tparser.ast.translate(elements);\n\n\t\tfor (const [key, value] of Object.entries(elements)) {\n\t\t\tthis[key] = value;\n\t\t}\n\n\t\tif (this.domain.length === 0) {\n\t\t\tthrow new Error(\"Domain cannot be empty.\");\n\t\t}\n\n\t\tif (!isEIP55Address(this.address)) {\n\t\t\tthrow new Error(\"Address not conformant to EIP-55.\");\n\t\t}\n\t}\n}\n", "function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \u03B8\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (\u03C1) and Pi (\u03C0)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (\u03C7)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (\u03B9)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n", "import { keccak_256 } from '@noble/hashes/sha3';\nimport { bytesToHex } from '@noble/hashes/utils';\n/**\n * This method is supposed to check if an address is conforming to EIP-55.\n * @param address Address to be checked if conforms with EIP-55.\n * @returns Either the return is or not in the EIP-55 format.\n */\nexport const isEIP55Address = (address: string) => {\n  if (address.length != 42) {\n    return false;\n  }\n\n  const lowerAddress = `${address}`.toLowerCase().replace('0x', '');\n  const hash = bytesToHex(keccak_256(lowerAddress));\n  let ret = '0x';\n\n  for (let i = 0; i < lowerAddress.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += lowerAddress[i].toUpperCase();\n    } else {\n      ret += lowerAddress[i];\n    }\n  }\n  return address === ret;\n};\n\nexport const parseIntegerNumber = (number: string): number => {\n  const parsed = parseInt(number);\n  if (Number.isNaN(parsed)) throw new Error('Invalid number.');\n  if (parsed === Infinity) throw new Error('Invalid number.');\n  return parsed;\n};\n", "// TODO: Figure out how to get types from this lib:\nimport {\n  isEIP55Address,\n  ParsedMessage,\n  parseIntegerNumber,\n} from './siwe-parse/parsers';\nimport { Provider } from 'ethers';\nimport * as uri from 'valid-url';\n\nimport { getAddress, verifyMessage } from './ethersCompat';\nimport {\n  SiweError,\n  SiweErrorType,\n  SiweResponse,\n  VerifyOpts,\n  VerifyOptsKeys,\n  VerifyParams,\n  VerifyParamsKeys,\n} from './types';\nimport {\n  checkContractWalletSignature,\n  generateNonce,\n  checkInvalidKeys,\n  isValidISO8601Date,\n} from './utils';\n\nexport class SiweMessage {\n  /**RFC 4501 dns authority that is requesting the signing. */\n  domain: string;\n  /**Ethereum address performing the signing conformant to capitalization\n   * encoded checksum specified in EIP-55 where applicable. */\n  address: string;\n  /**Human-readable ASCII assertion that the user will sign, and it must not\n   * contain `\\n`. */\n  statement?: string;\n  /**RFC 3986 URI referring to the resource that is the subject of the signing\n   *  (as in the __subject__ of a claim). */\n  uri: string;\n  /**Current version of the message. */\n  version: string;\n  /**EIP-155 Chain ID to which the session is bound, and the network where\n   * Contract Accounts must be resolved. */\n  chainId: number;\n  /**Randomized token used to prevent replay attacks, at least 8 alphanumeric\n   * characters. */\n  nonce: string;\n  /**ISO 8601 datetime string of the current time. */\n  issuedAt?: string;\n  /**ISO 8601 datetime string that, if present, indicates when the signed\n   * authentication message is no longer valid. */\n  expirationTime?: string;\n  /**ISO 8601 datetime string that, if present, indicates when the signed\n   * authentication message will become valid. */\n  notBefore?: string;\n  /**System-specific identifier that may be used to uniquely refer to the\n   * sign-in request. */\n  requestId?: string;\n  /**List of information or references to information the user wishes to have\n   * resolved as part of authentication by the relying party. They are\n   * expressed as RFC 3986 URIs separated by `\\n- `. */\n  resources?: Array<string>;\n\n  /**\n   * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a\n   * string or an object. If a string is used an ABNF parser is called to\n   * validate the parameter, otherwise the fields are attributed.\n   * @param param {string | SiweMessage} Sign message as a string or an object.\n   */\n  constructor(param: string | Partial<SiweMessage>) {\n    if (typeof param === 'string') {\n      const parsedMessage = new ParsedMessage(param);\n      this.domain = parsedMessage.domain;\n      this.address = parsedMessage.address;\n      this.statement = parsedMessage.statement;\n      this.uri = parsedMessage.uri;\n      this.version = parsedMessage.version;\n      this.nonce = parsedMessage.nonce;\n      this.issuedAt = parsedMessage.issuedAt;\n      this.expirationTime = parsedMessage.expirationTime;\n      this.notBefore = parsedMessage.notBefore;\n      this.requestId = parsedMessage.requestId;\n      this.chainId = parsedMessage.chainId;\n      this.resources = parsedMessage.resources;\n    } else {\n      this.domain = param.domain;\n      this.address = param.address;\n      this.statement = param?.statement;\n      this.uri = param.uri;\n      this.version = param.version;\n      this.chainId = param.chainId;\n      this.nonce = param.nonce;\n      this.issuedAt = param?.issuedAt;\n      this.expirationTime = param?.expirationTime;\n      this.notBefore = param?.notBefore;\n      this.requestId = param?.requestId;\n      this.resources = param?.resources;\n      if (typeof this.chainId === 'string') {\n        this.chainId = parseIntegerNumber(this.chainId);\n      }\n    }\n    this.nonce = this.nonce || generateNonce();\n    this.validateMessage();\n  }\n\n  /**\n   * This function can be used to retrieve an EIP-4361 formated message for\n   * signature, although you can call it directly it's advised to use\n   * [prepareMessage()] instead which will resolve to the correct method based\n   * on the [type] attribute of this object, in case of other formats being\n   * implemented.\n   * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.\n   */\n  toMessage(): string {\n    /** Validates all fields of the object */\n    this.validateMessage();\n\n    const header = `${this.domain} wants you to sign in with your Ethereum account:`;\n    const uriField = `URI: ${this.uri}`;\n    let prefix = [header, this.address].join('\\n');\n    const versionField = `Version: ${this.version}`;\n\n    if (!this.nonce) {\n      this.nonce = generateNonce();\n    }\n\n    const chainField = `Chain ID: ` + this.chainId || '1';\n\n    const nonceField = `Nonce: ${this.nonce}`;\n\n    const suffixArray = [uriField, versionField, chainField, nonceField];\n\n    this.issuedAt = this.issuedAt || new Date().toISOString();\n\n    suffixArray.push(`Issued At: ${this.issuedAt}`);\n\n    if (this.expirationTime) {\n      const expiryField = `Expiration Time: ${this.expirationTime}`;\n\n      suffixArray.push(expiryField);\n    }\n\n    if (this.notBefore) {\n      suffixArray.push(`Not Before: ${this.notBefore}`);\n    }\n\n    if (this.requestId) {\n      suffixArray.push(`Request ID: ${this.requestId}`);\n    }\n\n    if (this.resources) {\n      suffixArray.push(\n        [`Resources:`, ...this.resources.map(x => `- ${x}`)].join('\\n')\n      );\n    }\n\n    const suffix = suffixArray.join('\\n');\n    prefix = [prefix, this.statement].join('\\n\\n');\n    if (this.statement) {\n      prefix += '\\n';\n    }\n    return [prefix, suffix].join('\\n');\n  }\n\n  /**\n   * This method parses all the fields in the object and creates a messaging for signing\n   * message according with the type defined.\n   * @returns {string} Returns a message ready to be signed according with the\n   * type defined in the object.\n   */\n  prepareMessage(): string {\n    let message: string;\n    switch (this.version) {\n      case '1': {\n        message = this.toMessage();\n        break;\n      }\n\n      default: {\n        message = this.toMessage();\n        break;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * @deprecated\n   * Verifies the integrity of the object by matching its signature.\n   * @param signature Signature to match the address in the message.\n   * @param provider Ethers provider to be used for EIP-1271 validation\n   */\n  async validate(signature: string, provider?: Provider) {\n    console.warn(\n      'validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions.'\n    );\n    return this.verify({ signature }, { provider, suppressExceptions: false })\n      .then(({ data }) => data)\n      .catch(({ error }) => {\n        throw error;\n      });\n  }\n\n  /**\n   * Verifies the integrity of the object by matching its signature.\n   * @param params Parameters to verify the integrity of the message, signature is required.\n   * @returns {Promise<SiweMessage>} This object if valid.\n   */\n  async verify(\n    params: VerifyParams,\n    opts: VerifyOpts = { suppressExceptions: false }\n  ): Promise<SiweResponse> {\n    return new Promise<SiweResponse>((resolve, reject) => {\n      const fail = result => {\n        if (opts.suppressExceptions) {\n          return resolve(result);\n        } else {\n          return reject(result);\n        }\n      };\n\n      const invalidParams: Array<keyof VerifyParams> =\n        checkInvalidKeys<VerifyParams>(params, VerifyParamsKeys);\n      if (invalidParams.length > 0) {\n        fail({\n          success: false,\n          data: this,\n          error: new Error(\n            `${invalidParams.join(\n              ', '\n            )} is/are not valid key(s) for VerifyParams.`\n          ),\n        });\n      }\n\n      const invalidOpts: Array<keyof VerifyOpts> = checkInvalidKeys<VerifyOpts>(\n        opts,\n        VerifyOptsKeys\n      );\n      if (invalidParams.length > 0) {\n        fail({\n          success: false,\n          data: this,\n          error: new Error(\n            `${invalidOpts.join(', ')} is/are not valid key(s) for VerifyOpts.`\n          ),\n        });\n      }\n\n      const { signature, domain, nonce, time } = params;\n\n      /** Domain binding */\n      if (domain && domain !== this.domain) {\n        fail({\n          success: false,\n          data: this,\n          error: new SiweError(\n            SiweErrorType.DOMAIN_MISMATCH,\n            domain,\n            this.domain\n          ),\n        });\n      }\n\n      /** Nonce binding */\n      if (nonce && nonce !== this.nonce) {\n        fail({\n          success: false,\n          data: this,\n          error: new SiweError(SiweErrorType.NONCE_MISMATCH, nonce, this.nonce),\n        });\n      }\n\n      /** Check time or now */\n      const checkTime = new Date(time || new Date());\n\n      /** Message not expired */\n      if (this.expirationTime) {\n        const expirationDate = new Date(this.expirationTime);\n        if (checkTime.getTime() >= expirationDate.getTime()) {\n          fail({\n            success: false,\n            data: this,\n            error: new SiweError(\n              SiweErrorType.EXPIRED_MESSAGE,\n              `${checkTime.toISOString()} < ${expirationDate.toISOString()}`,\n              `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`\n            ),\n          });\n        }\n      }\n\n      /** Message is valid already */\n      if (this.notBefore) {\n        const notBefore = new Date(this.notBefore);\n        if (checkTime.getTime() < notBefore.getTime()) {\n          fail({\n            success: false,\n            data: this,\n            error: new SiweError(\n              SiweErrorType.NOT_YET_VALID_MESSAGE,\n              `${checkTime.toISOString()} >= ${notBefore.toISOString()}`,\n              `${checkTime.toISOString()} < ${notBefore.toISOString()}`\n            ),\n          });\n        }\n      }\n      let EIP4361Message;\n      try {\n        EIP4361Message = this.prepareMessage();\n      } catch (e) {\n        fail({\n          success: false,\n          data: this,\n          error: e,\n        });\n      }\n\n      /** Recover address from signature */\n      let addr;\n      try {\n        addr = verifyMessage(EIP4361Message, signature);\n      } catch (e) {\n        console.error(e);\n      }\n      /** Match signature with message's address */\n      if (addr === this.address) {\n        return resolve({\n          success: true,\n          data: this,\n        });\n      } else {\n        const EIP1271Promise = checkContractWalletSignature(\n          this,\n          signature,\n          opts.provider\n        )\n          .then(isValid => {\n            if (!isValid) {\n              return {\n                success: false,\n                data: this,\n                error: new SiweError(\n                  SiweErrorType.INVALID_SIGNATURE,\n                  addr,\n                  `Resolved address to be ${this.address}`\n                ),\n              };\n            }\n            return {\n              success: true,\n              data: this,\n            };\n          })\n          .catch(error => {\n            return {\n              success: false,\n              data: this,\n              error,\n            };\n          });\n\n        Promise.all([\n          EIP1271Promise,\n          opts\n            ?.verificationFallback?.(params, opts, this, EIP1271Promise)\n            ?.then(res => res)\n            ?.catch((res: SiweResponse) => res),\n        ]).then(([EIP1271Response, fallbackResponse]) => {\n          if (fallbackResponse) {\n            if (fallbackResponse.success) {\n              return resolve(fallbackResponse);\n            } else {\n              fail(fallbackResponse);\n            }\n          } else {\n            if (EIP1271Response.success) {\n              return resolve(EIP1271Response);\n            } else {\n              fail(EIP1271Response);\n            }\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Validates the values of this object fields.\n   * @throws Throws an {ErrorType} if a field is invalid.\n   */\n  private validateMessage(...args) {\n    /** Checks if the user might be using the function to verify instead of validate. */\n    if (args.length > 0) {\n      throw new SiweError(\n        SiweErrorType.UNABLE_TO_PARSE,\n        `Unexpected argument in the validateMessage function.`\n      );\n    }\n\n    /** `domain` check. */\n    if (\n      !this.domain ||\n      this.domain.length === 0 ||\n      !/[^#?]*/.test(this.domain)\n    ) {\n      throw new SiweError(\n        SiweErrorType.INVALID_DOMAIN,\n        `${this.domain} to be a valid domain.`\n      );\n    }\n\n    /** EIP-55 `address` check. */\n    if (!isEIP55Address(this.address)) {\n      throw new SiweError(\n        SiweErrorType.INVALID_ADDRESS,\n        getAddress(this.address),\n        this.address\n      );\n    }\n\n    /** Check if the URI is valid. */\n    if (!uri.isUri(this.uri)) {\n      throw new SiweError(\n        SiweErrorType.INVALID_URI,\n        `${this.uri} to be a valid uri.`\n      );\n    }\n\n    /** Check if the version is 1. */\n    if (this.version !== '1') {\n      throw new SiweError(\n        SiweErrorType.INVALID_MESSAGE_VERSION,\n        '1',\n        this.version\n      );\n    }\n\n    /** Check if the nonce is alphanumeric and bigger then 8 characters */\n    const nonce = this?.nonce?.match(/[a-zA-Z0-9]{8,}/);\n    if (!nonce || this.nonce.length < 8 || nonce[0] !== this.nonce) {\n      throw new SiweError(\n        SiweErrorType.INVALID_NONCE,\n        `Length > 8 (${nonce.length}). Alphanumeric.`,\n        this.nonce\n      );\n    }\n\n    /** `issuedAt` conforms to ISO-8601 and is a valid date. */\n    if (this.issuedAt) {\n      if (!isValidISO8601Date(this.issuedAt)) {\n        throw new Error(SiweErrorType.INVALID_TIME_FORMAT);\n      }\n    }\n\n    /** `expirationTime` conforms to ISO-8601 and is a valid date. */\n    if (this.expirationTime) {\n      if (!isValidISO8601Date(this.expirationTime)) {\n        throw new Error(SiweErrorType.INVALID_TIME_FORMAT);\n      }\n    }\n\n    /** `notBefore` conforms to ISO-8601 and is a valid date. */\n    if (this.notBefore) {\n      if (!isValidISO8601Date(this.notBefore)) {\n        throw new Error(SiweErrorType.INVALID_TIME_FORMAT);\n      }\n    }\n  }\n}\n", "/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n\n/**\n *  The current version of Ethers.\n */\nexport const version: string = \"6.8.1\";\n", "/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\n\nfunction checkType(value: any, type: string, name: string): void {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof(value) === type) { return; }\n        }\n    }\n\n    const error: any = new Error(`invalid value for type ${ type }`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${ name }`;\n    error.value = value;\n\n    throw error;\n}\n\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, <{ [ P in keyof T]: T[P] }>{ });\n}\n\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n", "/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\nimport { version } from \"../_version.js\";\n\nimport { defineProperties } from \"./properties.js\";\n\nimport type {\n    TransactionRequest, TransactionReceipt, TransactionResponse\n} from \"../providers/index.js\";\n\nimport type { FetchRequest, FetchResponse } from \"./fetch.js\";\n\n/**\n *  An error may contain additional properties, but those must not\n *  conflict with any impliciat properties.\n */\nexport type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\" | \"shortMessage\"> & { shortMessage?: string };\n\n\nfunction stringify(value: any): any {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${ stringify(k) }: ${ stringify(value[k]) }`).join(\", \") + \" }\";\n        }\n    }\n\n    return `[ COULD NOT SERIALIZE ]`;\n}\n\n/**\n *  All errors emitted by ethers have an **ErrorCode** to help\n *  identify and coalesce errors to simplfy programatic analysis.\n *\n *  Each **ErrorCode** is the %%code%% proerty of a coresponding\n *  [[EthersError]].\n *\n *  **Generic Errors**\n *\n *  **``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n *\n *  **``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n *\n *  **``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n *\n *  **``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n *\n *  **``\"SERVER_ERROR\"``** - see [[ServerError]]\n *\n *  **``\"TIMEOUT\"``** - see [[TimeoutError]]\n *\n *  **``\"BAD_DATA\"``** - see [[BadDataError]]\n *\n *  **``\"CANCELLED\"``** - see [[CancelledError]]\n *\n *  **Operational Errors**\n *\n *  **``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n *\n *  **``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n *\n *  **Argument Errors**\n *\n *  **``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n *\n *  **``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n *\n *  **``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n *\n *  **``\"VALUE_MISMATCH\"``** - //unused//\n *\n *  **Blockchain Errors**\n *\n *  **``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n *\n *  **``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n *\n *  **``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n *\n *  **``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n *\n *  **``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n *\n *  **``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n *\n *  **``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n *\n *  **User Interaction Errors**\n *\n *  **``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]\n */\nexport type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVALID_ARGUMENT\" | \"MISSING_ARGUMENT\" | \"UNEXPECTED_ARGUMENT\" |\n    \"VALUE_MISMATCH\" |\n\n    // Blockchain Errors\n    \"CALL_EXCEPTION\" | \"INSUFFICIENT_FUNDS\" | \"NONCE_EXPIRED\" |\n    \"REPLACEMENT_UNDERPRICED\" | \"TRANSACTION_REPLACED\" |\n    \"UNCONFIGURED_NAME\" | \"OFFCHAIN_FAULT\" |\n\n    // User Interaction\n    \"ACTION_REJECTED\"\n;\n\n/**\n *  All errors in Ethers include properties to assist in\n *  machine-readable errors.\n */\nexport interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additional info regarding the error that may be useful.\n     *\n     *  This is generally helpful mostly for human-based debugging.\n     */\n    info?: Record<string, any>;\n\n    /**\n     *  Any related error.\n     */\n    error?: Error;\n}\n\n// Generic Errors\n\n/**\n *  This Error is a catch-all for when there is no way for Ethers to\n *  know what the underlying problem is.\n */\nexport interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}\n\n/**\n *  This Error is mostly used as a stub for functionality that is\n *  intended for the future, but is currently not implemented.\n */\nexport interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates that the attempted operation is not supported.\n *\n *  This could range from a specifc JSON-RPC end-point not supporting\n *  a feature to a specific configuration of an object prohibiting the\n *  operation.\n *\n *  For example, a [[Wallet]] with no connected [[Provider]] is unable\n *  to send a transaction.\n */\nexport interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates a proplem connecting to a network.\n */\nexport interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}\n\n/**\n *  This Error indicates there was a problem fetching a resource from\n *  a server.\n */\nexport interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}\n\n/**\n *  This Error indicates that the timeout duration has expired and\n *  that the operation has been implicitly cancelled.\n *\n *  The side-effect of the operation may still occur, as this\n *  generally means a request has been sent and there has simply\n *  been no response to indicate whether it was processed or not.\n */\nexport interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}\n\n/**\n *  This Error indicates that a provided set of data cannot\n *  be correctly interpretted.\n */\nexport interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}\n\n/**\n *  This Error indicates that the operation was cancelled by a\n *  programmatic call, for example to ``cancel()``.\n */\nexport interface CancelledError extends EthersError<\"CANCELLED\"> {\n}\n\n\n// Operational Errors\n\n/**\n *  This Error indicates an attempt was made to read outside the bounds\n *  of protected data.\n *\n *  Most operations in Ethers are protected by bounds checks, to mitigate\n *  exploits when parsing data.\n */\nexport interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n}\n\n/**\n *  This Error indicates an operation which would result in incorrect\n *  arithmetic output has occurred.\n *\n *  For example, trying to divide by zero or using a ``uint8`` to store\n *  a negative value.\n */\nexport interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}\n\n\n// Argument Errors\n\n/**\n *  This Error indicates an incorrect type or value was passed to\n *  a function or method.\n */\nexport interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}\n\n/**\n *  This Error indicates there were too few arguments were provided.\n */\nexport interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n/**\n *  This Error indicates too many arguments were provided.\n */\nexport interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n\n// Blockchain Errors\n\n/**\n *  The action that resulted in the call exception.\n */\nexport type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";\n\n/**\n *  The related transaction that caused the error.\n */\nexport type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};\n\n/**\n *  This **Error** indicates a transaction reverted.\n */\nexport interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-readable representation of data, if possible.\n     */\n    reason: null | string;\n\n    /**\n     *  The transaction that triggered the exception.\n     */\n    transaction: CallExceptionTransaction,\n\n    /**\n     *  The contract invocation details, if available.\n     */\n    invocation: null | {\n        method: string;\n        signature: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  The built-in or custom revert error, if available\n     */\n    revert: null | {\n        signature: string;\n        name: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  If the error occurred in a transaction that was mined\n     *  (with a status of ``0``), this is the receipt.\n     */\n    receipt?: TransactionReceipt;   // @TODO: in v7, make this `null | TransactionReceipt`\n}\n\n\n/**\n *  The sending account has insufficient funds to cover the\n *  entire transaction cost.\n */\nexport interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  The sending account has already used this nonce in a\n *  transaction that has been included.\n */\nexport interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A CCIP-read exception, which cannot be recovered from or\n *  be further processed.\n */\nexport interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}\n\n/**\n *  An attempt was made to replace a transaction, but with an\n *  insufficient additional fee to afford evicting the old\n *  transaction from the memory pool.\n */\nexport interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A pending transaction was replaced by another.\n */\nexport interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was replaced.\n     */\n    reason: \"repriced\" | \"cancelled\" | \"replaced\";\n\n    /**\n     *  The hash of the replaced transaction.\n     */\n    hash: string;\n\n    /**\n     *  The transaction that replaced the transaction.\n     */\n    replacement: TransactionResponse;\n\n    /**\n     *  The receipt of the transaction that replace the transaction.\n     */\n    receipt: TransactionReceipt;\n}\n\n/**\n *  This Error indicates an ENS name was used, but the name has not\n *  been configured.\n *\n *  This could indicate an ENS name is unowned or that the current\n *  address being pointed to is the [[ZeroAddress]].\n */\nexport interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}\n\n/**\n *  This Error indicates a request was rejected by the user.\n *\n *  In most clients (such as MetaMask), when an operation requires user\n *  authorization (such as ``signer.sendTransaction``), the client\n *  presents a dialog box to the user. If the user denies the request\n *  this error is thrown.\n */\nexport interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n     *  If there is already a pending request, some clients may indicate\n     *  there is already a ``\"pending\"`` action. This prevents an app\n     *  from spamming the user.\n     */\n    reason: \"expired\" | \"rejected\" | \"pending\"\n}\n\n// Coding; converts an ErrorCode its Typed Error\n\n/**\n *  A conditional type that transforms the [[ErrorCode]] T into\n *  its EthersError type.\n *\n *  @flatworm-skip-docs\n */\nexport type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T extends \"TIMEOUT\" ? TimeoutError:\n    T extends \"BAD_DATA\" ? BadDataError:\n    T extends \"CANCELLED\" ? CancelledError:\n\n    T extends \"BUFFER_OVERRUN\" ? BufferOverrunError:\n    T extends \"NUMERIC_FAULT\" ? NumericFaultError:\n\n    T extends \"INVALID_ARGUMENT\" ? InvalidArgumentError:\n    T extends \"MISSING_ARGUMENT\" ? MissingArgumentError:\n    T extends \"UNEXPECTED_ARGUMENT\" ? UnexpectedArgumentError:\n\n    T extends \"CALL_EXCEPTION\" ? CallExceptionError:\n    T extends \"INSUFFICIENT_FUNDS\" ? InsufficientFundsError:\n    T extends \"NONCE_EXPIRED\" ? NonceExpiredError:\n    T extends \"OFFCHAIN_FAULT\" ? OffchainFaultError:\n    T extends \"REPLACEMENT_UNDERPRICED\" ? ReplacementUnderpricedError:\n    T extends \"TRANSACTION_REPLACED\" ? TransactionReplacedError:\n    T extends \"UNCONFIGURED_NAME\" ? UnconfiguredNameError:\n\n    T extends \"ACTION_REJECTED\" ? ActionRejectedError:\n\n    never;\n\n\n\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}\n\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */\nexport function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${ stringify(info) }`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") { continue; }\n                const value = <any>(info[<keyof ErrorInfo<T>>key]);\n//                try {\n                    details.push(key + \"=\" + stringify(value));\n//                } catch (error: any) {\n//                console.log(\"MMM\", error.message);\n//                    details.push(key + \"=[could not serialize object]\");\n//                }\n            }\n        }\n        details.push(`code=${ code }`);\n        details.push(`version=${ version }`);\n\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n\n    defineProperties<EthersError>(<EthersError>error, { code });\n\n    if (info) { Object.assign(error, info); }\n\n    if ((<any>error).shortMessage == null) {\n        defineProperties<EthersError>(<EthersError>error, { shortMessage });\n    }\n\n    return <T>error;\n}\n\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}\n\n\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\n\nexport function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\n\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") { throw new Error(\"bad\"); };\n        /* c8 ignore stop */\n\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301)\n            /* c8 ignore start */\n            if (check !== expected) { throw new Error(\"broken\") }\n            /* c8 ignore stop */\n        }\n\n        accum.push(form);\n    } catch(error) { }\n\n    return accum;\n}, <Array<string>>[]);\n\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${ method }from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n", "/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n", "/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n", "/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nimport { defineProperties } from \"./properties.js\";\n\n/**\n *  A callback function called when a an event is triggered.\n */\nexport type Listener = (...args: Array<any>) => void;\n\n/**\n *  An **EventEmitterable** behaves similar to an EventEmitter\n *  except provides async access to its methods.\n *\n *  An EventEmitter implements the observer pattern.\n */\nexport interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event%% occurs.\n     */\n    once(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Triggers each listener for %%event%% with the %%args%%.\n     */\n    emit(event: T, ...args: Array<any>): Promise<boolean>;\n\n    /**\n     *  Resolves to the number of listeners for %%event%%.\n     */\n    listenerCount(event?: T): Promise<number>;\n\n    /**\n     *  Resolves to the listeners for %%event%%.\n     */\n    listeners(event?: T): Promise<Array<Listener>>;\n\n    /**\n     *  Unregister the %%listener%% for %%event%%. If %%listener%%\n     *  is unspecified, all listeners are unregistered.\n     */\n    off(event: T, listener?: Listener): Promise<this>;\n\n    /**\n     *  Unregister all listeners for %%event%%.\n     */\n    removeAllListeners(event?: T): Promise<this>;\n\n    /**\n     *  Alias for [[on]].\n     */\n    addListener(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Alias for [[off]].\n     */\n    removeListener(event: T, listener: Listener): Promise<this>;\n}\n\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nexport class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter: EventEmitterable<T>, listener: null | Listener, filter: T) {\n        this.#listener = listener;\n        defineProperties<EventPayload<any>>(this, { emitter, filter });\n    }\n\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener(): Promise<void> {\n        if (this.#listener == null) { return; }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n", "/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument, assertNormalize } from \"./errors.js\";\n\nimport type { BytesLike } from \"./index.js\";\n\n\n///////////////////////////////\n\n/**\n *  The stanard normalization forms.\n */\nexport type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";\n\n/**\n *  When using the UTF-8 error API the following errors can be intercepted\n *  and processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n *\n *  **``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\n *  was nothing to continue.\n *\n *  **``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\n *  UTF-8 codepoint was found.\n *\n *  **``\"OVERRUN\"``** - the string is too short to process the expected\n *  codepoint length.\n *\n *  **``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\n *  not found. The %%offset%% indicates the index the continuation byte\n *  was expected at.\n *\n *  **``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\n *  for UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\n *  outside the valid UTF-8 range.\n *\n *  **``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\n *  pair. The %%badCodepoint%% is the computed codepoint, which was inside the\n *  UTF-16 surrogate range.\n *\n *  **``\"OVERLONG\"``** - the string is an overlong representation. The\n *  %%badCodepoint%% indicates the computed codepoint, which has already\n *  been bounds checked.\n *\n *\n *  @returns string\n */\nexport type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";\n\n\n/**\n *  A callback that can be used with [[toUtf8String]] to analysis or\n *  recovery from invalid UTF-8 data.\n *\n *  Parsing UTF-8 data is done through a simple Finite-State Machine (FSM)\n *  which calls the ``Utf8ErrorFunc`` if a fault is detected.\n *\n *  The %%reason%% indicates where in the FSM execution the fault\n *  occurred and the %%offset%% indicates where the input failed.\n *\n *  The %%bytes%% represents the raw UTF-8 data that was provided and\n *  %%output%% is the current array of UTF-8 code-points, which may\n *  be updated by the ``Utf8ErrorFunc``.\n *\n *  The value of the %%badCodepoint%% depends on the %%reason%%. See\n *  [[Utf8ErrorReason]] for details.\n *\n *  The function should return the number of bytes that should be skipped\n *  when control resumes to the FSM.\n */\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;\n\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n    assertArgument(false, `invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        assertArgument(typeof(badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nexport const Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    const bytes = getBytes(_bytes, \"bytes\");\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength: null | number = null;\n        let overlongMask: null | number = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res: null | number = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result: Array<number> = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00),\n                \"invalid surrogate pair\", \"str\", str);\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return new Uint8Array(result);\n};\n\n//export \nfunction _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n\n", "\nimport {\n    defineProperties, concat, getBytesCopy, getNumber, hexlify,\n    toBeArray, toBigInt, toNumber,\n    assert, assertArgument\n} from \"../../utils/index.js\";\n\nimport type { BigNumberish, BytesLike } from \"../../utils/index.js\";\n\n/**\n * @_ignore:\n */\nexport const WordSize: number = 32;\nconst Padding = new Uint8Array(WordSize);\n\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [ \"then\" ];\n\nconst _guard = { };\n\nfunction throwError(name: string, error: Error): never {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${ name }`);\n    (<any>wrapped).error = error;\n    throw wrapped;\n}\n\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array<any> {\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @private\n     */\n    constructor(...args: Array<any>) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items: Array<any> = args[1];\n        let names: Array<null | string> = (args[2] || [ ]).slice();\n\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [ ];\n            wrap = false;\n        }\n\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof(name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, <Map<string, number>>(new Map()));\n\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n\n        if (!wrap) { return; }\n\n        // A wrapped Result is immutable\n        Object.freeze(this);\n\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"string\") {\n\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${ index }`, item);\n                        }\n                        return item;\n                    }\n\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(this: any, ...args: Array<any>) {\n                            return value.apply((this === receiver) ? target: this, args);\n                        };\n\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target: this, [ prop ]);\n                    }\n                }\n\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            result.push(item);\n        });\n        return result;\n    }\n\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(): Record<string, any> {\n        return this.#names.reduce((accum, name, index) => {\n            assert(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n\n            return accum;\n        }, <Record<string, any>>{});\n    }\n\n    /**\n     *  @_ignore\n     */\n    slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) { end = 0; }\n        }\n        if (end > this.length) { end = this.length; }\n\n        const result: Array<any> = [ ], names: Array<null | string> = [ ];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const result: Array<any> = [ ], names: Array<null | string> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    map<T extends any = any>(callback: (el: any, index: number, array: Result) => T, thisArg?: any): Array<T> {\n        const result: Array<T> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            result.push(callback.call(thisArg, item, i, this));\n        }\n\n        return result;\n    }\n\n\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name: string): any {\n        const index = this.#names.indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n        return value;\n    }\n\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items: Array<any>, keys?: Array<null | string>): Result {\n        return new Result(_guard, items, keys);\n    }\n}\n\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error: any) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nfunction getValue(value: BigNumberish): Uint8Array {\n    let bytes = toBeArray(value);\n\n    assert (bytes.length <= WordSize, \"value out-of-bounds\",\n        \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([ Padding.slice(bytes.length % WordSize), bytes ]));\n    }\n\n    return bytes;\n}\n\n/**\n *  @_ignore\n */\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName!: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic!: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        defineProperties<Coder>(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n\n    _throwError(message: string, value: any): never {\n        assertArgument(false, message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get length(): number { return this.#dataLength; }\n\n    #writeData(data: Uint8Array): number {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([ bytes, Padding.slice(paddingOffset) ]))\n        }\n        return this.#writeData(bytes);\n    }\n\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value: BigNumberish): number {\n        return this.#writeData(getValue(value));\n    }\n\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value: BigNumberish) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly allowLoose!: boolean;\n\n    readonly #data: Uint8Array;\n    #offset: number;\n\n    constructor(data: BytesLike, allowLoose?: boolean) {\n        defineProperties<Reader>(this, { allowLoose: !!allowLoose });\n\n        this.#data = getBytesCopy(data);\n\n        this.#offset = 0;\n    }\n\n    get data(): string { return hexlify(this.#data); }\n    get dataLength(): number { return this.#data.length; }\n    get consumed(): number { return this.#offset; }\n    get bytes(): Uint8Array { return new Uint8Array(this.#data); }\n\n    #peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\n    }\n\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset: number): Reader {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n\n    // Read bytes\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    // Read a numeric values\n    readValue(): bigint {\n        return toBigInt(this.readBytes(WordSize));\n    }\n\n    readIndex(): number {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n", "import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\n\nimport { keccak_256 } from \"@noble/hashes/sha3\";\n\nimport { getBytes, hexlify } from \"../utils/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\n\nlet locked = false;\n\nconst _keccak256 = function(data: Uint8Array): Uint8Array {\n    return keccak_256(data);\n}\n\nlet __keccak256: (data: Uint8Array) => BytesLike = _keccak256;\n\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function(): void { locked = true; }\nkeccak256.register = function(func: (data: Uint8Array) => BytesLike) {\n    if (locked) { throw new TypeError(\"keccak256 is locked\"); }\n    __keccak256 = func;\n}\nObject.freeze(keccak256);\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) \u2261 1    if a is a square (mod p)\n  // (a | p) \u2261 -1   if a is not a square (mod p)\n  // (a | p) \u2261 0    if a \u2261 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) \u2261 -1 and set c \u2261 zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be \u2261 -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P \u2261 3 (mod 4)\n  // \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q \u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P \u2261 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n     * - \uD835\uDC4A is the window size\n     * - \uD835\uDC5B is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y\u00B2 = x\u00B3 + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y\u00B2 = x\u00B3 + ax + b: Short weierstrass curve formula\n   * @returns y\u00B2\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) \u220B (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      if (this.is0()) {\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\n        // In BLS, ZERO can be serialized, so we allow it.\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y\u00B2\n      const right = weierstrassEquation(x); // x\u00B3 + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) \u220B (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n        let y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1\u22C5G - U2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1\u22C5G + u2\u22C5P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x \u2265 p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'\u22C5G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s\u22C5G - e\u22C5P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n", "/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */\nexport const ZeroHash: string = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n", "// NFKC (composed)             // (decomposed)\n\n/**\n *  A constant for the ether symbol (normalized using NFKC).\n *\n *  (**i.e.** ``\"\\\\u039e\"``)\n */\nexport const EtherSymbol: string = \"\\u039e\";  // \"\\uD835\\uDF63\";\n\n\n/**\n *  A constant for the [[link-eip-191]] personal message prefix.\n *\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\n */\nexport const MessagePrefix: string = \"\\x19Ethereum Signed Message:\\n\";\n", "\nimport { ZeroHash } from \"../constants/index.js\";\nimport {\n    concat, dataLength, getBigInt, getBytes, getNumber, hexlify,\n    toBeArray, isHexString, zeroPadValue,\n    assertArgument, assertPrivate\n} from \"../utils/index.js\";\n\nimport type {\n    BigNumberish, BytesLike, Numeric\n} from \"../utils/index.js\";\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\n\n\nconst _guard = { };\n\n// @TODO: Allow Uint8Array\n\n/**\n *  A SignatureLike\n *\n *  @_docloc: api/crypto:Signing\n */\nexport type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 | 1;\n    v?: BigNumberish;\n    yParityAndS?: string;\n};\n\nfunction toUint256(value: BigNumberish): string {\n    return zeroPadValue(toBeArray(value), 32);\n}\n\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r(): string { return this.#r; }\n    set r(value: BytesLike) {\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = hexlify(value);\n    }\n\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s(): string { return this.#s; }\n    set s(_value: BytesLike) {\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = hexlify(_value);\n        assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v(): 27 | 28 { return this.#v; }\n    set v(value: BigNumberish) {\n        const v = getNumber(value, \"value\");\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV(): null | bigint { return this.#networkV; }\n\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId(): null | bigint {\n        const v = this.networkV;\n        if (v == null) { return null; }\n        return Signature.getChainId(v);\n    }\n\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity(): 0 | 1 {\n        return (this.v === 27) ? 0: 1;\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS(): string {\n        // The EIP-2098 compact representation\n        const yParityAndS = getBytes(this.s);\n        if (this.yParity) { yParityAndS[0] |= 0x80; }\n        return hexlify(yParityAndS);\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized(): string {\n        return concat([ this.r, this.yParityAndS ]);\n    }\n\n    /**\n     *  The serialized representation.\n     */\n    get serialized(): string {\n        return concat([ this.r, this.s, (this.yParity ? \"0x1c\": \"0x1b\") ]);\n    }\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, r: string, s: string, v: 27 | 28) {\n        assertPrivate(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n\n    [Symbol.for('nodejs.util.inspect.custom')](): string {\n        return `Signature { r: \"${ this.r }\", s: \"${ this.s }\", yParity: ${ this.yParity }, networkV: ${ this.networkV } }`;\n    }\n\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone(): Signature {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) { clone.#networkV = this.networkV; }\n        return clone;\n    }\n\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON(): any {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString(): null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v: BigNumberish): bigint {\n        const bv = getBigInt(v, \"v\");\n\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) { return BN_0; }\n\n        // Bad value for an EIP-155 v\n        assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n\n        return (bv - BN_35) / BN_2;\n    }\n\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId: BigNumberish, v: 27 | 28): bigint {\n        return (getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v: BigNumberish): 27 | 28 {\n        const bv = getBigInt(v);\n\n        if (bv === BN_0 || bv === BN_27) { return 27; }\n        if (bv === BN_1 || bv === BN_28) { return 28; }\n\n        assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27: 28;\n    }\n\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig?: SignatureLike): Signature {\n        function assertError(check: unknown, message: string): asserts check {\n            assertArgument(check, message, \"signature\", sig);\n        };\n\n        if (sig == null) {\n            return new Signature(_guard, ZeroHash, ZeroHash, 27);\n        }\n\n        if (typeof(sig) === \"string\") {\n            const bytes = getBytes(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28: 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n\n            if (bytes.length === 65) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n\n            assertError(false, \"invalid raw signature length\");\n        }\n\n        if (sig instanceof Signature) { return sig.clone(); }\n\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function(s?: string, yParityAndS?: string) {\n            if (s != null) { return toUint256(s); }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = getBytes(yParityAndS);\n                bytes[0] &= 0x7f;\n                return hexlify(bytes);\n            }\n\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function(_v?: BigNumberish, yParityAndS?: string, yParity?: Numeric): { networkV?: bigint, v: 27 | 28 } {\n            if (_v != null) {\n                const v = getBigInt(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v: undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28: 27) };\n            }\n\n            if (yParity != null) {\n                switch (getNumber(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) { result.#networkV =  networkV; }\n\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n\n        return result;\n    }\n}\n\n", "/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\n\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\n\nimport {\n    concat, dataLength, getBytes, getBytesCopy, hexlify, toBeHex,\n    assertArgument\n} from \"../utils/index.js\";\n\nimport { Signature } from \"./signature.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type { SignatureLike } from \"./index.js\";\n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\nexport class SigningKey {\n    #privateKey: string;\n\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey: BytesLike) {\n        assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = hexlify(privateKey);\n    }\n\n    /**\n     *  The private key.\n     */\n    get privateKey(): string { return this.#privateKey; }\n\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */\n    get publicKey(): string { return SigningKey.computePublicKey(this.#privateKey); }\n\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */\n    get compressedPublicKey(): string { return SigningKey.computePublicKey(this.#privateKey, true); }\n\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */\n    sign(digest: BytesLike): Signature {\n        assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n\n        const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {\n            lowS: true\n        });\n\n        return Signature.from({\n            r: toBeHex(sig.r, 32),\n            s: toBeHex(sig.s, 32),\n            v: (sig.recovery ? 0x1c: 0x1b)\n        });\n    }\n\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */\n    computeSharedSecret(other: BytesLike): string {\n        const pubKey = SigningKey.computePublicKey(other);\n        return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));\n    }\n\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */\n    static computePublicKey(key: BytesLike, compressed?: boolean): string {\n        let bytes = getBytes(key, \"key\");\n\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = secp256k1.getPublicKey(bytes, !!compressed);\n            return hexlify(pubKey);\n        }\n\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n\n        const point = secp256k1.ProjectivePoint.fromHex(bytes);\n        return hexlify(point.toRawBytes(compressed));\n    }\n\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */\n    static recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n        assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n\n        const sig = Signature.from(signature);\n\n        let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([ sig.r, sig.s ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n\n        const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));\n        assertArgument(pubKey != null, \"invalid signautre for digest\", \"signature\", signature);\n\n        return \"0x\" + pubKey.toHex(false);\n    }\n\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */\n    static addPoints(p0: BytesLike, p1: BytesLike, compressed?: boolean): string {\n        const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed)\n    }\n}\n\n", "import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\n\nfunction getChecksumAddress(address: string): string {\n//    if (!isHexString(address, 20)) {\n//        logger.throwArgumentError(\"invalid address\", \"address\", address);\n//    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = getBytes(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nconst Base36 = (function() {;\n    const result: Record<string, bigint> = { };\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\n\nfunction fromBase36(value: string): bigint {\n    value = value.toLowerCase();\n\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n        const result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address,\n            \"bad address checksum\", \"address\", address);\n\n        return result;\n    }\n\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) { result = \"0\" + result; }\n        return  getChecksumAddress(\"0x\" + result);\n    }\n\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n", "import { assert, assertArgument } from \"../utils/index.js\";\n\nimport { getAddress } from \"./address.js\";\n\nimport type { Addressable, AddressLike, NameResolver } from \"./index.js\";\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nexport function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}\n\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nexport function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nasync function checkAddress(target: any, promise: Promise<null | string>): Promise<string> {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        assert(typeof(target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return getAddress(result);\n}\n\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nexport function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n\n        return checkAddress(target, resolver.resolveName(target));\n\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n\n    } else if (target && typeof(target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}\n", "/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\n\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\n\nimport type { Addressable } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\nimport type { Result } from \"./coders/abstract-coder.js\";\n\nconst _gaurd = { };\n\nfunction n(value: BigNumberish, width: number): Typed {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${ signed ? \"\": \"u\" }int${ width }`, value, { signed, width });\n}\n\nfunction b(value: BytesLike, size?: number): Typed {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${ (size) ? size: \"\" }`, value, { size });\n}\n\n// @TODO: Remove this in v7, it was replaced by TypedBigInt\n/**\n *  @_ignore:\n */\nexport interface TypedNumber extends Typed {\n    value: number;\n    defaultValue(): number;\n    minValue(): number;\n    maxValue(): number;\n}\n\n/**\n *  A **Typed** that represents a numeric value.\n */\nexport interface TypedBigInt extends Typed {\n    /**\n     *  The value.\n     */\n    value: bigint;\n\n    /**\n     *  The default value for all numeric types is ``0``.\n     */\n    defaultValue(): bigint;\n\n    /**\n     *  The minimum value for this type, accounting for bit-width and signed-ness.\n     */\n    minValue(): bigint;\n\n    /**\n     *  The minimum value for this type, accounting for bit-width.\n     */\n    maxValue(): bigint;\n}\n\n/**\n *  A **Typed** that represents a binary sequence of data as bytes.\n */\nexport interface TypedData extends Typed {\n    /**\n     *  The value.\n     */\n    value: string;\n\n    /**\n     *  The default value for this type.\n     */\n    defaultValue(): string;\n}\n\n/**\n *  A **Typed** that represents a UTF-8 sequence of bytes.\n */\nexport interface TypedString extends Typed {\n    /**\n     *  The value.\n     */\n    value: string;\n\n    /**\n     *  The default value for the string type is the empty string (i.e. ``\"\"``).\n     */\n    defaultValue(): string;\n}\n\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nexport class Typed {\n\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    readonly type!: string;\n\n    /**\n     *  The actual value.\n     */\n    readonly value!: any;\n\n    readonly #options: any;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _typedSymbol!: Symbol;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd: any, type: string, value: any, options?: any) {\n        if (options == null) { options = null; }\n        assertPrivate(_gaurd, gaurd, \"Typed\");\n        defineProperties<Typed>(this, { _typedSymbol, type, value });\n        this.#options = options;\n\n        // Check the value is valid\n        this.format();\n    }\n\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format(): string {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${ this.value.map((v: Typed) => v.format()).join(\",\") })`\n        }\n\n        return this.type;\n    }\n\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue(): string | number | bigint | Result {\n        return 0;\n    }\n\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue(): string | number | bigint {\n        return 0;\n    }\n\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue(): string | number | bigint {\n        return 0;\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt(): this is TypedBigInt {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData(): this is TypedData {\n        return this.type.startsWith(\"bytes\");\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString(): this is TypedString {\n        return (this.type === \"string\");\n    }\n\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName(): null | string {\n        if (this.type !== \"tuple\") { throw TypeError(\"not a tuple\"); }\n        return this.#options;\n    }\n\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength(): null | number {\n        if (this.type !== \"array\") { throw TypeError(\"not an array\"); }\n        if (this.#options === true) { return -1; }\n        if (this.#options === false) { return (<Array<any>>(this.value)).length; }\n        return null;\n    }\n\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type: string, value: any): Typed {\n        return new Typed(_gaurd, type, value);\n    }\n\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v: BigNumberish): Typed { return n(v, 8); }\n\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v: BigNumberish): Typed { return n(v, 16); }\n\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v: BigNumberish): Typed { return n(v, 24); }\n\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v: BigNumberish): Typed { return n(v, 32); }\n\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v: BigNumberish): Typed { return n(v, 40); }\n\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v: BigNumberish): Typed { return n(v, 48); }\n\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v: BigNumberish): Typed { return n(v, 56); }\n\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v: BigNumberish): Typed { return n(v, 64); }\n\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v: BigNumberish): Typed { return n(v, 72); }\n\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v: BigNumberish): Typed { return n(v, 80); }\n\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v: BigNumberish): Typed { return n(v, 88); }\n\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v: BigNumberish): Typed { return n(v, 96); }\n\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v: BigNumberish): Typed { return n(v, 104); }\n\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v: BigNumberish): Typed { return n(v, 112); }\n\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v: BigNumberish): Typed { return n(v, 120); }\n\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v: BigNumberish): Typed { return n(v, 128); }\n\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v: BigNumberish): Typed { return n(v, 136); }\n\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v: BigNumberish): Typed { return n(v, 144); }\n\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v: BigNumberish): Typed { return n(v, 152); }\n\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v: BigNumberish): Typed { return n(v, 160); }\n\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v: BigNumberish): Typed { return n(v, 168); }\n\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v: BigNumberish): Typed { return n(v, 176); }\n\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v: BigNumberish): Typed { return n(v, 184); }\n\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v: BigNumberish): Typed { return n(v, 192); }\n\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v: BigNumberish): Typed { return n(v, 200); }\n\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v: BigNumberish): Typed { return n(v, 208); }\n\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v: BigNumberish): Typed { return n(v, 216); }\n\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v: BigNumberish): Typed { return n(v, 224); }\n\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v: BigNumberish): Typed { return n(v, 232); }\n\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v: BigNumberish): Typed { return n(v, 240); }\n\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v: BigNumberish): Typed { return n(v, 248); }\n\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v: BigNumberish): Typed { return n(v, 256); }\n\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v: BigNumberish): Typed { return n(v, 256); }\n\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v: BigNumberish): Typed { return n(v, -8); }\n\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v: BigNumberish): Typed { return n(v, -16); }\n\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v: BigNumberish): Typed { return n(v, -24); }\n\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v: BigNumberish): Typed { return n(v, -32); }\n\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v: BigNumberish): Typed { return n(v, -40); }\n\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v: BigNumberish): Typed { return n(v, -48); }\n\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v: BigNumberish): Typed { return n(v, -56); }\n\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v: BigNumberish): Typed { return n(v, -64); }\n\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v: BigNumberish): Typed { return n(v, -72); }\n\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v: BigNumberish): Typed { return n(v, -80); }\n\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v: BigNumberish): Typed { return n(v, -88); }\n\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v: BigNumberish): Typed { return n(v, -96); }\n\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v: BigNumberish): Typed { return n(v, -104); }\n\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v: BigNumberish): Typed { return n(v, -112); }\n\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v: BigNumberish): Typed { return n(v, -120); }\n\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v: BigNumberish): Typed { return n(v, -128); }\n\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v: BigNumberish): Typed { return n(v, -136); }\n\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v: BigNumberish): Typed { return n(v, -144); }\n\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v: BigNumberish): Typed { return n(v, -152); }\n\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v: BigNumberish): Typed { return n(v, -160); }\n\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v: BigNumberish): Typed { return n(v, -168); }\n\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v: BigNumberish): Typed { return n(v, -176); }\n\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v: BigNumberish): Typed { return n(v, -184); }\n\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v: BigNumberish): Typed { return n(v, -192); }\n\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v: BigNumberish): Typed { return n(v, -200); }\n\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v: BigNumberish): Typed { return n(v, -208); }\n\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v: BigNumberish): Typed { return n(v, -216); }\n\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v: BigNumberish): Typed { return n(v, -224); }\n\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v: BigNumberish): Typed { return n(v, -232); }\n\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v: BigNumberish): Typed { return n(v, -240); }\n\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v: BigNumberish): Typed { return n(v, -248); }\n\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v: BigNumberish): Typed { return n(v, -256); }\n\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v: BigNumberish): Typed { return n(v, -256); }\n\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v: BytesLike): Typed { return b(v, 1); }\n\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v: BytesLike): Typed { return b(v, 2); }\n\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v: BytesLike): Typed { return b(v, 3); }\n\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v: BytesLike): Typed { return b(v, 4); }\n\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v: BytesLike): Typed { return b(v, 5); }\n\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v: BytesLike): Typed { return b(v, 6); }\n\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v: BytesLike): Typed { return b(v, 7); }\n\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v: BytesLike): Typed { return b(v, 8); }\n\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v: BytesLike): Typed { return b(v, 9); }\n\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v: BytesLike): Typed { return b(v, 10); }\n\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v: BytesLike): Typed { return b(v, 11); }\n\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v: BytesLike): Typed { return b(v, 12); }\n\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v: BytesLike): Typed { return b(v, 13); }\n\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v: BytesLike): Typed { return b(v, 14); }\n\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v: BytesLike): Typed { return b(v, 15); }\n\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v: BytesLike): Typed { return b(v, 16); }\n\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v: BytesLike): Typed { return b(v, 17); }\n\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v: BytesLike): Typed { return b(v, 18); }\n\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v: BytesLike): Typed { return b(v, 19); }\n\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v: BytesLike): Typed { return b(v, 20); }\n\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v: BytesLike): Typed { return b(v, 21); }\n\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v: BytesLike): Typed { return b(v, 22); }\n\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v: BytesLike): Typed { return b(v, 23); }\n\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v: BytesLike): Typed { return b(v, 24); }\n\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v: BytesLike): Typed { return b(v, 25); }\n\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v: BytesLike): Typed { return b(v, 26); }\n\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v: BytesLike): Typed { return b(v, 27); }\n\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v: BytesLike): Typed { return b(v, 28); }\n\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v: BytesLike): Typed { return b(v, 29); }\n\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v: BytesLike): Typed { return b(v, 30); }\n\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v: BytesLike): Typed { return b(v, 31); }\n\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v: BytesLike): Typed { return b(v, 32); }\n\n\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v: string | Addressable): Typed { return new Typed(_gaurd, \"address\", v); }\n\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v: any): Typed { return new Typed(_gaurd, \"bool\", !!v); }\n\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v: BytesLike): Typed { return new Typed(_gaurd, \"bytes\", v); }\n\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v: string): Typed { return new Typed(_gaurd, \"string\", v); }\n\n\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v: Array<any | Typed>, dynamic?: null | boolean): Typed {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n\n\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v: Array<any | Typed> | Record<string, any | Typed>, name?: string): Typed {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n\n\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v: Record<string, any>): Typed {\n        return new Typed(_gaurd, \"overrides\", Object.assign({ }, v));\n    }\n\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value: any): value is Typed {\n        return (value\n            && typeof(value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference<T>(value: Typed | T, type: string): T {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${ type }, got ${ value.type }`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n", "import { getAddress } from \"../../address/index.js\";\nimport { toBeHex } from \"../../utils/maths.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n        let value = Typed.dereference(_value, \"string\");\n        try {\n            value = getAddress(value);\n        } catch (error: any) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(toBeHex(reader.readValue(), 20));\n    }\n}\n", "import { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n", "import {\n    defineProperties, isError, assert, assertArgument, assertArgumentCount\n} from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\n\nimport { Coder, Result, WordSize, Writer } from \"./abstract-coder.js\";\nimport { AnonymousCoder } from \"./anonymous.js\";\n\nimport type { Reader } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = [ ];\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            assert(name, \"cannot encode object for signature with missing names\",\n                \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n\n            assert(!unique[name], \"cannot encode object for signature with duplicate names\",\n                \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        assertArgument(false, \"invalid tuple value\", \"tuple\", values);\n    }\n\n    assertArgument(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n\n    let staticWriter = new Writer();\n    let dynamicWriter = new Writer();\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\n/**\n *  @_ignore\n */\nexport function unpack(reader: Reader, coders: ReadonlyArray<Coder>): Result {\n    let values: Array<any> = [];\n    let keys: Array<null | string> = [ ];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error: any) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error: any) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n\n    return Result.fromItems(values, keys);\n}\n\n/**\n *  @_ignore\n */\nexport class ArrayCoder extends Coder {\n    readonly coder!: Coder;\n    readonly length!: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        defineProperties<ArrayCoder>(this, { coder, length });\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, _value: Array<any> | Typed): number {\n        const value = Typed.dereference(_value, \"array\");\n\n        if(!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        assertArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders: Array<Coder> = [ ];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            assert(count * WordSize <= reader.dataLength, \"insufficient data length\",\n                \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });\n        }\n        let coders: Array<Coder> = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return unpack(reader, coders);\n    }\n}\n\n", "import { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, _value: boolean | Typed): number {\n        const value = Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return !!reader.readValue();\n    }\n}\n", "import { getBytesCopy, hexlify } from \"../../utils/index.js\";\n\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = getBytesCopy(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return hexlify(super.decode(reader));\n    }\n}\n", "\nimport { defineProperties, getBytesCopy, hexlify } from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { BytesLike } from \"../../utils/index.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class FixedBytesCoder extends Coder {\n    readonly size!: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        defineProperties<FixedBytesCoder>(this, { size }, { size: \"number\" });\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, _value: BytesLike | Typed): number {\n        let data = getBytesCopy(Typed.dereference(_value, this.type));\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", _value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return hexlify(reader.readBytes(this.size));\n    }\n}\n", "import { Coder } from \"./abstract-coder.js\";\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\nconst Empty = new Uint8Array([ ]);\n\n/**\n *  @_ignore\n */\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes(Empty);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return null;\n    }\n}\n", "import {\n    defineProperties, fromTwos, getBigInt, mask, toTwos\n} from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder, WordSize } from \"./abstract-coder.js\";\n\nimport type { BigNumberish } from \"../../utils/index.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n/**\n *  @_ignore\n */\nexport class NumberCoder extends Coder {\n    readonly size!: number;\n    readonly signed!: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        defineProperties<NumberCoder>(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, _value: BigNumberish | Typed): number {\n        let value = getBigInt(Typed.dereference(_value, this.type));\n\n        // Check bounds are safe for encoding\n        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);\n        if (this.signed) {\n            let bounds = mask(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = toTwos(value, 8 * WordSize);\n        } else if (value < BN_0 || value > mask(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        let value = mask(reader.readValue(), this.size * 8);\n\n        if (this.signed) {\n            value = fromTwos(value, this.size * 8);\n        }\n\n        return value;\n    }\n}\n\n", "import { toUtf8Bytes, toUtf8String } from \"../../utils/utf8.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { DynamicBytesCoder } from \"./bytes.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, \"string\")));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n", "import { defineProperties } from \"../../utils/properties.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport { pack, unpack } from \"./array.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport class TupleCoder extends Coder {\n    readonly coders!: ReadonlyArray<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        defineProperties<TupleCoder>(this, { coders: Object.freeze(coders.slice()) });\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, _value: Array<any> | { [ name: string ]: any } | Typed): number {\n        const value = Typed.dereference(_value, \"tuple\");\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return unpack(reader, this.coders);\n    }\n}\n\n", "import { keccak256 } from \"../crypto/index.js\";\nimport { toUtf8Bytes } from \"../utils/index.js\";\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nexport function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}\n", "import { getAddress } from \"../address/index.js\";\nimport { assertArgument, isHexString } from \"../utils/index.js\";\n\nimport type { AccessList, AccessListish } from \"./index.js\";\n\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            assertArgument(isHexString(storageKey, 32), \"invalid slot\", `storageKeys[${ index }]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.length === 2, \"invalid slot set\", `value[${ index }]`, set);\n                return accessSetify(set[0], set[1])\n            }\n            assertArgument(set != null && typeof(set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    assertArgument(value != null && typeof(value) === \"object\", \"invalid access list\", \"value\", value);\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n", "import { getAddress } from \"../address/index.js\";\nimport { keccak256, SigningKey } from \"../crypto/index.js\";\n\nimport type { SignatureLike } from \"../crypto/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nexport function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).substring(26));\n}\n\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}\n", "import { keccak256 } from \"../crypto/index.js\";\nimport { MessagePrefix } from \"../constants/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, toUtf8Bytes } from \"../utils/index.js\";\n\nimport type { SignatureLike } from \"../crypto/index.js\";\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */\nexport function hashMessage(message: Uint8Array | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(MessagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nexport function verifyMessage(message: Uint8Array | string, sig: SignatureLike): string {\n    const digest = hashMessage(message);\n    return recoverAddress(digest, sig);\n}\n", "/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\nimport {\n    defineProperties, getBigInt, getNumber,\n    assert, assertPrivate, assertArgument\n} from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n\n/**\n *  A Type description in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The internal Solidity type.\n     */\n    readonly internalType?: string;\n\n    /**\n     *  The components for a tuple.\n     */\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\n/**\n *  A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n    readonly anonymous?: boolean;\n\n    /**\n     *  If the function is payable.\n     */\n    readonly payable?: boolean;\n\n    /**\n     *  If the function is constant.\n     */\n    readonly constant?: boolean;\n\n    /**\n     *  The mutability state of the function.\n     */\n    readonly stateMutability?: string;\n\n    /**\n     *  The input parameters.\n     */\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The output parameters.\n     */\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The gas limit to use when sending a transaction for this function.\n     */\n    readonly gas?: string;\n};\n\n/**\n *  The format to serialize the output as.\n *\n *  **``\"sighash\"``** - the bare formatting, used to compute the selector\n *  or topic hash; this format cannot be reversed (as it discards ``indexed``)\n *  so cannot by used to export an [[Interface]].\n *\n *  **``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\n *  names, so it is compact, but will result in Result objects that cannot\n *  be accessed by name.\n *\n *  **``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\n *  intact; this is generally the recommended format.\n *\n *  **``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).\n */\nexport type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";\n\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items: Array<string>): ReadonlySet<string> {\n    const result: Set<string> = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\n\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\n\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\n\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\n\nconst _kwOther = \"tuple returns\";\n\n// All Keywords\nconst _keywords = [ _kwTypes, _kwModifiers, _kwOther, _kwVisib ].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n\n// Single character tokens\nconst SimpleTokens: Record<string, string> = {\n  \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\", \"@\": \"AT\"\n};\n\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\n\n/**\n *  @ignore:\n */\ntype Token = Readonly<{\n    // Type of token (e.g. TYPE, KEYWORD, NUMBER, etc)\n    type: string;\n\n    // Offset into the original source code\n    offset: number;\n\n    // Actual text content of the token\n    text: string;\n\n    // The parenthesis depth\n    depth: number;\n\n    // If a parenthesis, the offset (in tokens) that balances it\n    match: number;\n\n    // For parenthesis and commas, the offset (in tokens) to the\n    // previous/next parenthesis or comma in the list\n    linkBack: number;\n    linkNext: number;\n\n    // If a BRACKET, the value inside\n    value: number;\n}>;\n\nclass TokenString {\n    #offset: number;\n    #tokens: ReadonlyArray<Token>;\n\n    get offset(): number { return this.#offset; }\n    get length(): number { return this.#tokens.length - this.#offset; }\n\n    constructor(tokens: ReadonlyArray<Token>) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n\n    clone(): TokenString { return new TokenString(this.#tokens); }\n    reset(): void { this.#offset = 0; }\n\n    #subTokenString(from: number = 0, to: number = 0): TokenString {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({ }, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed: ReadonlySet<string>): string {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) { throw new Error(`expected keyword ${ top.text }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type: string): string {\n        if (this.peek().type !== type) { throw new Error(`expected ${ type }; got ${ JSON.stringify(this.peek()) }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen(): TokenString {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams(): Array<TokenString> {\n        const top = this.peek();\n\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n\n        const result: Array<TokenString> = [ ];\n\n        while(this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n\n        this.#offset = top.match + 1;\n\n        return result;\n    }\n\n    // Returns the top Token, throwing if out of tokens\n    peek(): Token {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed: ReadonlySet<string>): null | string {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top: null;\n    }\n\n    // Returns the value of the next token if it is `type`\n    peekType(type: string): null | string {\n        if (this.length === 0) { return null; }\n        const top = this.peek();\n        return (top.type === type) ? top.text: null;\n    }\n\n    // Returns the next token; throws if out of tokens\n    pop(): Token {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n\n    toString(): string {\n        const tokens: Array<string> = [ ];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${ token.type }:${ token.text }`);\n        }\n        return `<TokenString ${ tokens.join(\" \") }>`\n    }\n}\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction lex(text: string): TokenString {\n    const tokens: Array<Token> = [ ];\n\n    const throwError = (message: string) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]): \"$EOI\";\n        throw new Error(`invalid token ${ token } at ${ offset }: ${ message }`);\n    };\n\n    let brackets: Array<number> = [ ];\n    let commas: Array<number> = [ ];\n\n    let offset = 0;\n    while (offset < text.length) {\n\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) { throwError(\"no matching open bracket\"); }\n\n                token.match = brackets.pop() as number;\n                (<Writeable<Token>>(tokens[token.match])).match = tokens.length - 1;\n                token.depth--;\n\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = (tokens.pop() as Token).text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = (tokens.pop() as Token).text;\n                    suffix = value + suffix;\n                    (<Writeable<Token>>(tokens[tokens.length - 1])).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (<Writeable<Token>>(tokens[tokens.length - 1])).text += suffix;\n            }\n\n            continue;\n        }\n\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n\n            token.type = \"ID\";\n            continue;\n        }\n\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n\n        throw new Error(`unexpected token ${ JSON.stringify(cur[0]) } at position ${ offset }`);\n    }\n\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set: ReadonlySet<string>, allowed: ReadonlySet<string>): void {\n    let included: Array<string> = [ ];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) { included.push(key); }\n    }\n    if (included.length > 1) { throw new Error(`conflicting types: ${ included.join(\", \") }`); }\n}\n\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n\n// ...the name with an optional type, returning the name\nfunction consumeName(type: string, tokens: TokenString): string {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${ type }, got ${ keyword }`);\n        }\n    }\n\n    return tokens.popType(\"ID\");\n}\n\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens: TokenString, allowed?: ReadonlySet<string>): ReadonlySet<string> {\n    const keywords: Set<string> = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n\n        if (keyword == null || (allowed && !allowed.has(keyword))) { break; }\n        tokens.pop();\n\n        if (keywords.has(keyword)) { throw new Error(`duplicate keywords: ${ JSON.stringify(keyword) }`); }\n        keywords.add(keyword);\n    }\n\n    return Object.freeze(keywords);\n}\n\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens: TokenString): \"payable\" | \"nonpayable\" | \"view\" | \"pure\" {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n\n    // Process mutability states\n    if (modifiers.has(\"view\")) { return \"view\"; }\n    if (modifiers.has(\"pure\")) { return \"pure\"; }\n    if (modifiers.has(\"payable\")) { return \"payable\"; }\n    if (modifiers.has(\"nonpayable\")) { return \"nonpayable\"; }\n\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) { return \"view\"; }\n\n    return \"nonpayable\";\n}\n\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens: TokenString, allowIndexed?: boolean): Array<ParamType> {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens: TokenString): null | bigint {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\n\nfunction consumeEoi(tokens: TokenString): void {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${ tokens.toString() }`);\n    }\n}\n\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nfunction verifyBasicType(type: string): string {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") { return \"uint256\"; }\n    if (type === \"int\") { return \"int256\"; }\n\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3] as string);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n\n    return type;\n}\n\n// Make the Fragment constructors effectively private\nconst _guard = { };\n\n\n/**\n *  When [walking](ParamType-walk) a [[ParamType]], this is called\n *  on each component.\n */\nexport type ParamTypeWalkFunc = (type: string, value: any) => any;\n\n/**\n *  When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\n *  this is called on each component.\n */\nexport type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;\n\nconst internal = Symbol.for(\"_ethers_internal\");\n\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    readonly baseType!: string;\n\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    readonly indexed!: null | boolean;\n\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    readonly components!: null | ReadonlyArray<ParamType>;\n\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayLength!: null | number;\n\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayChildren!: null | ParamType;\n\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, type: string, baseType: string, indexed: null | boolean, components: null | ReadonlyArray<ParamType>, arrayLength: null | number, arrayChildren: null | ParamType) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n\n        if (components) { components = Object.freeze(components.slice()); }\n\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n\n        if (baseType === \"tuple\") {\n            if (components == null) { throw new Error(\"\"); }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n\n        defineProperties<ParamType>(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n                return JSON.stringify(result);\n            }\n\n            const result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name\n            };\n\n\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n        } else {\n            if (this.isTuple()) {\n                if (format !== \"sighash\") { result += this.type; }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === \"full\") ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== \"sighash\") {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray(): this is (ParamType & { arrayChildren: ParamType, arrayLength: number }) {\n        return (this.baseType === \"array\")\n    }\n\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple(): this is (ParamType & { components: ReadonlyArray<ParamType> }) {\n        return (this.baseType === \"tuple\");\n    }\n\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable(): this is (ParamType & { indexed: boolean }) {\n        return (this.indexed != null);\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value: any, process: ParamTypeWalkFunc): any {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid tuple value\"); }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n\n        return process(this.type, value);\n    }\n\n    #walkAsync(promises: Array<Promise<void>>, value: any, process: ParamTypeWalkAsyncFunc, setValue: (value: any) => void): void {\n\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        if (this.isTuple()) {\n            const components = this.components;\n\n            // Convert the object into an array\n            let result: Array<any>;\n            if (Array.isArray(value)) {\n                result = value.slice();\n\n            } else {\n                if (value == null || typeof(value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n\n                result = components.map((param) => {\n                    if (!param.name) { throw new Error(\"cannot use object value with unnamed components\"); }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${ param.name }`);\n                    }\n                    return value[param.name];\n                });\n            }\n\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function() { setValue(await result); })());\n        } else {\n            setValue(result);\n        }\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value: any, process: ParamTypeWalkAsyncFunc): Promise<any> {\n        const promises: Array<Promise<void>> = [ ];\n        const result: [ any ] = [ value ];\n        this.#walkAsync(promises, value, process, (value: any) => {\n            result[0] = value;\n        });\n        if (promises.length) { await Promise.all(promises); }\n        return result[0];\n    }\n\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj: any, allowIndexed?: boolean): ParamType {\n        if (ParamType.isParamType(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                assertArgument(false, \"invalid param type\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps: null | Array<ParamType> = null;\n\n            if (consumeKeywords(obj, setify([ \"tuple\" ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${ comps.map((c) => c.format()).join(\",\") })`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n\n            // Check for Array\n            let arrayChildren: null | ParamType  = null;\n            let arrayLength: null | number = null;\n\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n\n            let indexed: null | boolean = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) { throw new Error(\"\"); }\n                indexed = true;\n            }\n\n            const name = (obj.peekType(\"ID\") ? obj.pop().text: \"\");\n\n            if (obj.length) { throw new Error(\"leftover tokens\"); }\n\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n\n        const name = obj.name;\n        assertArgument(!name || (typeof(name) === \"string\" && name.match(regexId)),\n            \"invalid name\", \"obj.name\", name);\n\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n\n        let type = obj.type;\n\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n\n        if (type === \"tuple\" || type.startsWith(\"tuple(\"/* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c: any) => ParamType.from(c)): null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n\n        type = verifyBasicType(obj.type);\n\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value: any): value is ParamType {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n\n/**\n *  The type of a [[Fragment]].\n */\nexport type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";\n\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<Fragment>(this, { type, inputs });\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    abstract format(format?: FormatType): string;\n\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj: any): Fragment {\n        if (typeof(obj) === \"string\") {\n\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) { }\n\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n\n            const type = obj.peekKeyword(KwTypes);\n\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n        } else if (typeof(obj) === \"object\") {\n            // JSON ABI\n\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n            assert(false, `unsupported type: ${ obj.type }`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value: any): value is ConstructorFragment {\n        return ConstructorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value: any): value is ErrorFragment {\n        return ErrorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value: any): value is EventFragment {\n        return EventFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value: any): value is FunctionFragment {\n        return FunctionFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value: any): value is StructFragment {\n        return StructFragment.isFragment(value);\n    }\n}\n\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);\n        assertArgument(typeof(name) === \"string\" && name.match(regexId),\n            \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<NamedFragment>(this, { name });\n    }\n}\n\nfunction joinParams(format: FormatType, params: ReadonlyArray<ParamType>): string { \n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \": \",\") + \")\";\n}\n\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /**\n     *  The Custom Error selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        const result: Array<string> = [ ];\n        if (format !== \"sighash\") { result.push(\"error\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj: any): ErrorFragment {\n        if (ErrorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n\n            return new ErrorFragment(_guard, name, inputs);\n        }\n\n        return new ErrorFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value: any): value is ErrorFragment {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties<EventFragment>(this, { anonymous });\n    }\n\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash(): string {\n        return id(this.format(\"sighash\"));\n    }\n\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result: Array<string> = [ ];\n        if (format !== \"sighash\") { result.push(\"event\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) { result.push(\"anonymous\"); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj: any): EventFragment {\n        if (EventFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([ \"anonymous\" ])).has(\"anonymous\");\n            consumeEoi(obj);\n\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n\n        return new EventFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map((p: any) => ParamType.from(p, true)): [ ], !!obj.anonymous);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value: any): value is EventFragment {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>, payable: boolean, gas: null | bigint) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties<ConstructorFragment>(this, { payable, gas });\n    }\n\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format?: FormatType): string {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\": \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ `constructor${ joinParams(format, this.inputs) }` ];\n        if (this.payable) { result.push(\"payable\"); }\n        if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj: any): ConstructorFragment {\n        if (ConstructorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([ \"constructor\" ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n\n        return new ConstructorFragment(_guard, \"constructor\",\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n            !!obj.payable, (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value: any): value is ConstructorFragment {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties<FallbackFragment>(this, { payable });\n    }\n\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format?: FormatType): string {\n        const type = ((this.inputs.length === 0) ? \"receive\": \"fallback\");\n\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\": \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n\n        return `${ type }()${ this.payable ? \" payable\": \"\" }`;\n    }\n\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj: any): FallbackFragment {\n        if (FallbackFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n\n            const topIsValid = obj.peekKeyword(setify([ \"fallback\", \"receive\" ]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n\n            const type = obj.popKeyword(setify([ \"fallback\", \"receive\" ]));\n\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([ \"payable\" ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [ ], true);\n            }\n\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\",\n                    \"invalid fallback inputs\", \"obj.inputs\",\n                    inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [ ParamType.from(\"bytes\") ];\n            }\n\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\",\n                    \"invalid fallback outputs\", \"obj.outputs\",\n                    outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n\n            consumeEoi(obj);\n\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [ ], true);\n        }\n\n        if (obj.type === \"fallback\") {\n            const inputs = [ ParamType.from(\"bytes\") ];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value: any): value is FallbackFragment {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    readonly stateMutability!: \"payable\" | \"nonpayable\" | \"view\" | \"pure\";\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, stateMutability: \"payable\" | \"nonpayable\" | \"view\" | \"pure\", inputs: ReadonlyArray<ParamType>, outputs: ReadonlyArray<ParamType>, gas: null | bigint) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties<FunctionFragment>(this, { constant, gas, outputs, payable, stateMutability });\n    }\n\n    /**\n     *  The Function selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n\n        const result: Array<string> = [];\n\n        if (format !== \"sighash\") { result.push(\"function\"); }\n\n        result.push(this.name + joinParams(format, this.inputs));\n\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n\n            if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [ ], null);\n        return fragment.selector;\n    }\n\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj: any): FunctionFragment {\n        if (FunctionFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n\n            let outputs: Array<ParamType> = [ ];\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n\n            const gas = consumeGas(obj);\n\n            consumeEoi(obj);\n\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n\n        let stateMutability = obj.stateMutability;\n\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n\n            if (typeof(obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\"\n                    if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n\n        return new FunctionFragment(_guard, obj.name, stateMutability,\n             obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n             obj.outputs ? obj.outputs.map(ParamType.from): [ ],\n             (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format(): string {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj: any): StructFragment {\n        if (typeof(obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n// @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n\n", "/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { assertArgumentCount, assertArgument } from \"../utils/index.js\";\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder.js\";\nimport { AddressCoder } from \"./coders/address.js\";\nimport { ArrayCoder } from \"./coders/array.js\";\nimport { BooleanCoder } from \"./coders/boolean.js\";\nimport { BytesCoder } from \"./coders/bytes.js\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes.js\";\nimport { NullCoder } from \"./coders/null.js\";\nimport { NumberCoder } from \"./coders/number.js\";\nimport { StringCoder } from \"./coders/string.js\";\nimport { TupleCoder } from \"./coders/tuple.js\";\nimport { ParamType } from \"./fragments.js\";\n\nimport { getAddress } from \"../address/index.js\";\nimport { getBytes, hexlify, makeError } from \"../utils/index.js\";\n\nimport type {\n    BytesLike,\n    CallExceptionAction, CallExceptionError, CallExceptionTransaction\n} from \"../utils/index.js\";\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons: Map<number, string> = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nlet defaultCoder: null | AbiCoder = null;\n\n\nfunction getBuiltinCallException(action: CallExceptionAction, tx: { to?: null | string, from?: null | string, data?: string }, data: null | BytesLike, abiCoder: AbiCoder): CallExceptionError {\n    let message = \"missing revert data\";\n\n    let reason: null | string = null;\n    const invocation = null;\n    let revert: null | { signature: string, name: string, args: Array<any> } = null;\n\n    if (data) {\n        message = \"execution reverted\";\n\n        const bytes = getBytes(data);\n        data = hexlify(data);\n\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([ \"string\" ], bytes.slice(4))[0]\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [ reason ]\n                };\n                message += `: ${ JSON.stringify(reason) }`;\n\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([ \"uint256\" ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [ code ]\n                };\n                reason = `Panic due to ${ PanicReasons.get(code) || \"UNKNOWN\" }(${ code })`;\n                message += `: ${ reason }`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n\n    const transaction: CallExceptionTransaction = {\n        to: (tx.to ? getAddress(tx.to): null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) { transaction.from = getAddress(tx.from); }\n\n    return makeError(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */\nexport class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            assertArgument(size !== 0 && size <= 256 && (size % 8) === 0,\n                \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            assertArgument(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        assertArgument(false, \"invalid type\", \"type\", param.type);\n    }\n\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        assertArgumentCount(values.length, types.length, \"types/values length mismatch\");\n\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = new Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(new Reader(data, loose));\n    }\n\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder(): AbiCoder {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action: CallExceptionAction, tx: { to?: null | string, from?: null | string, data?: string }, data: null | BytesLike): CallExceptionError {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\n", "/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\nimport { keccak256 } from \"../crypto/index.js\"\nimport { id } from \"../hash/index.js\"\nimport {\n    concat, dataSlice, getBigInt, getBytes, getBytesCopy,\n    hexlify, zeroPadBytes, zeroPadValue, isHexString, defineProperties,\n    assertArgument, toBeHex, assert\n} from \"../utils/index.js\";\n\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport {\n    ConstructorFragment, ErrorFragment, EventFragment, FallbackFragment,\n    Fragment, FunctionFragment, ParamType\n} from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\n\nimport type { BigNumberish, BytesLike, CallExceptionError, CallExceptionTransaction } from \"../utils/index.js\";\n\nimport type { JsonFragment } from \"./fragments.js\";\n\n\nexport { checkResultErrors, Result };\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The topic hash for the Event.\n     */\n    readonly topic!: string;\n\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    readonly args!: Result\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: EventFragment, topic: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<LogDescription>(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    readonly selector!: string;\n\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    readonly value!: bigint;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: FunctionFragment, selector: string, args: Result, value: bigint) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<TransactionDescription>(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Error signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Error.\n     */\n    readonly selector!: string;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: ErrorFragment, selector: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<ErrorDescription>(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(hash: null | string) {\n        defineProperties<Indexed>(this, { hash, _isIndexed: true })\n    }\n}\n\ntype ErrorInfo = {\n    signature: string,\n    inputs: Array<string>,\n    name: string,\n    reason: (...args: Array<any>) => string;\n};\n\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons: Record<string, string> = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n}\n\nconst BuiltinErrors: Record<string, ErrorInfo> = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [ \"string\" ],\n        reason: (message: string) => {\n            return `reverted with reason string ${ JSON.stringify(message) }`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [ \"uint256\" ],\n        reason: (code: bigint) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${ code.toString(16) } (${ reason })`;\n        }\n    }\n}\n\n/*\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n*/\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\n\n/**\n *  An **InterfaceAbi** may be any supported ABI format.\n *\n *  A string is expected to be a JSON string, which will be parsed\n *  using ``JSON.parse``. This means that the value **must** be a valid\n *  JSON string, with no stray commas, etc.\n *\n *  An array may contain any combination of:\n *  - Human-Readable fragments\n *  - Parsed JSON fragment\n *  - [[Fragment]] instances\n *\n *  A **Human-Readable Fragment** is a string which resembles a Solidity\n *  signature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\n *  For example, ``function balanceOf(address) view returns (uint)``.\n *\n *  A **Parsed JSON Fragment** is a JavaScript Object desribed in the\n *  [Solidity documentation](link-solc-jsonabi).\n */\nexport type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;\n\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if any.\n     */\n    readonly fallback!: null | FallbackFragment;\n\n    /**\n     *  If receiving ether is supported.\n     */\n    readonly receive!: boolean;\n\n    #errors: Map<string, ErrorFragment>;\n    #events: Map<string, EventFragment>;\n    #functions: Map<string, FunctionFragment>;\n//    #structs: Map<string, StructFragment>;\n\n    #abiCoder: AbiCoder;\n\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments: InterfaceAbi) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n//        this.#structs = new Map();\n\n\n        const frags: Array<Fragment> = [ ];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n\n        defineProperties<Interface>(this, {\n            fragments: Object.freeze(frags)\n        });\n\n        let fallback: null | FallbackFragment = null;\n        let receive = false;\n\n        this.#abiCoder = this.getAbiCoder();\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket: Map<string, Fragment>;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties<Interface>(this, { deploy: <ConstructorFragment>fragment });\n                    return;\n\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        assertArgument(!fallback || (<FallbackFragment>fragment).payable !== fallback.payable,\n                            \"conflicting fallback fragments\", `fragments[${ index }]`, fragment);\n                        fallback = <FallbackFragment>fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n\n                default:\n                    return;\n            }\n\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) { return; }\n\n            bucket.set(signature, fragment);\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties<Interface>(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n\n        defineProperties<Interface>(this, { fallback, receive });\n    }\n\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal?: boolean): Array<string> {\n        const format = (minimal ? \"minimal\": \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson(): string {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder(): AbiCoder {\n        return AbiCoder.defaultAbiCoder();\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key: string, values: null | Array<any | Typed>, forceUnique: boolean): null | FunctionFragment {\n\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<FunctionFragment> = [ ];\n            for (const [ name, fragment ] of this.#functions) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1]: null;\n\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") { continue; }\n                            matching.splice(i, 1);\n                            break;\n                        }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof(lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key: string): string {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key: string): boolean {\n        return !!this.#getFunction(key, null, false);\n    }\n\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key: string, values?: Array<any | Typed>): null | FunctionFragment {\n        return this.#getFunction(key, values || null, true);\n    }\n\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback: (func: FunctionFragment, index: number) => void): void {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<FunctionFragment>(this.#functions.get(name)), i);\n        }\n    }\n\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key: string, values: null | Array<null | any | Typed>, forceUnique: boolean): null | EventFragment {\n\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<EventFragment> = [ ];\n            for (const [ name, fragment ] of this.#events) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key: string): string {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key: string): boolean {\n        return !!this.#getEvent(key, null, false);\n    }\n\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment {\n        return this.#getEvent(key, values || null, true)\n    }\n\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback: (func: EventFragment, index: number) => void): void {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<EventFragment>(this.#events.get(name)), i);\n        }\n    }\n\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<ErrorFragment> = [ ];\n            for (const [ name, fragment ] of this.#errors) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (matching.length === 0) {\n                if (key === \"Error\") { return ErrorFragment.from(\"error Error(string)\"); }\n                if (key === \"Panic\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${ matchStr })`, \"name\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format()\n        if (key === \"Error(string)\") { return ErrorFragment.from(\"error Error(string)\"); }\n        if (key === \"Panic(uint256)\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n\n        const result = this.#errors.get(key);\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback: (func: ErrorFragment, index: number) => void): void {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<ErrorFragment>(this.#errors.get(name)), i);\n        }\n    }\n\n    // Get the 4-byte selector used by Solidity to identify a function\n        /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n        if (typeof(fragment) === \"string\") {\n            const matches: Array<Fragment> = [ ];\n\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n            if (matches.length === 0) {\n                logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n            } else if (matches.length > 1) {\n                logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n            }\n\n            fragment = matches[0];\n        }\n\n        return dataSlice(id(fragment.format()), 0, 4);\n    }\n        */\n\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this.#abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this.#abiCoder.encode(params, values)\n    }\n\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match error ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match function ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        let message = \"invalid length for result data\";\n\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n\n    makeError(_data: BytesLike, tx: CallExceptionTransaction): CallExceptionError {\n        const data = getBytes(_data, \"data\");\n\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${ error.reason }`\n                 } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`\n                }\n            }\n        }\n\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n\n        return error;\n    }\n\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || [ ]));\n    }\n/*\n    spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n        const promises: Array<Promise<>> = [ ];\n        const process = function(type: ParamType, value: any): any {\n            if (type.baseType === \"array\") {\n                return descend(type.child\n            }\n            if (type. === \"address\") {\n            }\n        };\n\n        const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n            if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n            \n        };\n\n        const result: Array<any> = [ ];\n        values.forEach((value, index) => {\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n    }\n*/\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment: EventFragment | string, values: ReadonlyArray<any>): Array<null | string | Array<string>> {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${ fragment.format() }`,\n            \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length })\n\n        const topics: Array<null | string | Array<string>> = [];\n        if (!fragment.anonymous) { topics.push(fragment.topicHash); }\n\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            } else if (param.type.match(/^u?int/)) {\n                value = toBeHex(value);  // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = zeroPadBytes(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode( [ \"address\" ], [ value ]);\n            }\n\n            return zeroPadValue(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            const param = (<EventFragment>fragment).inputs[index];\n\n            if (!param.indexed) {\n                assertArgument(value == null,\n                    \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(fragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n\n        assertArgument(values.length === fragment.inputs.length,\n            \"event arguments/values mismatch\", \"values\", values);\n\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this.#abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic,\n                \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n\n        const indexed: Array<ParamType> = [];\n        const nonIndexed: Array<ParamType> = [];\n        const dynamic: Array<boolean> = [];\n\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)): null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values: Array<any> = [ ];\n        const keys: Array<null | string> = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value: null | Indexed | Error = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error: any) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error: any) {\n                    value = error;\n                }\n            }\n\n            values.push(value);\n            keys.push(param.name || null);\n        });\n\n        return Result.fromItems(values, keys);\n    }\n\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx: { data: string, value?: BigNumberish }): null | TransactionDescription {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value: 0, \"tx.value\");\n\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n\n    parseCallResult(data: BytesLike): Result {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log: { topics: Array<string>, data: string}): null | LogDescription {\n        const fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data: BytesLike): null | ErrorDescription {\n        const hexData = hexlify(data);\n\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value: InterfaceAbi | Interface): Interface {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) { return value; }\n\n        // JSON\n        if (typeof(value) === \"string\") { return new Interface(JSON.parse(value)); }\n\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof((<any>value).format) === \"function\") {\n            return new Interface((<any>value).format(\"json\"));\n        }\n\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n", "//import { resolveAddress } from \"@ethersproject/address\";\nimport {\n    defineProperties, getBigInt, getNumber, hexlify, resolveProperties,\n    assert, assertArgument, isError, makeError\n} from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\n\nimport type { AddressLike, NameResolver } from \"../address/index.js\";\nimport type { BigNumberish, EventEmitterable } from \"../utils/index.js\";\nimport type { Signature } from \"../crypto/index.js\";\nimport type { AccessList, AccessListish, TransactionLike } from \"../transaction/index.js\";\n\nimport type { ContractRunner } from \"./contracts.js\";\nimport type { Network } from \"./network.js\";\n\n\nconst BN_0 = BigInt(0);\n\n/**\n *  A **BlockTag** specifies a specific block.\n *\n *  **numeric value** - specifies the block height, where\n *  the genesis block is block 0; many operations accept a negative\n *  value which indicates the block number should be deducted from\n *  the most recent block. A numeric value may be a ``number``, ``bigint``,\n *  or a decimal of hex string.\n *\n *  **blockhash** - specifies a specific block by its blockhash; this allows\n *  potentially orphaned blocks to be specifed, without ambiguity, but many\n *  backends do not support this for some operations.\n */\nexport type BlockTag = BigNumberish | string;\n\nimport {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\n// -----------------------\n\nfunction getValue<T>(value: undefined | null | T): null | T {\n    if (value == null) { return null; }\n    return value;\n}\n\nfunction toJson(value: null | bigint): null | string {\n    if (value == null) { return null; }\n    return value.toString();\n}\n\n// @TODO? <T extends FeeData = { }> implements Required<T>\n\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    readonly maxFeePerGas!: null | bigint;\n\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    readonly maxPriorityFeePerGas!: null | bigint;\n\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint) {\n        defineProperties<FeeData>(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON(): any {\n        const {\n            gasPrice, maxFeePerGas, maxPriorityFeePerGas\n        } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n\n\n/**\n *  A **TransactionRequest** is a transactions with potentially various\n *  properties not defined, or with less strict types for its values.\n *\n *  This is used to pass to various operations, which will internally\n *  coerce any types and populate any necessary values.\n */\nexport interface TransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: null | number;\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: null | AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: null | AddressLike;\n\n    /**\n     *  The nonce of the transaction, used to prevent replay attacks.\n     */\n    nonce?: null | number;\n\n    /**\n     *  The maximum amount of gas to allow this transaction to consime.\n     */\n    gasLimit?: null | BigNumberish;\n\n    /**\n     *  The gas price to use for legacy transactions or transactions on\n     *  legacy networks.\n     *\n     *  Most of the time the ``max*FeePerGas`` is preferred.\n     */\n    gasPrice?: null | BigNumberish;\n\n    /**\n     *  The [[link-eip-1559]] maximum priority fee to pay per gas.\n     */\n    maxPriorityFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual\n     *  value used is protocol enforced to be the block's base fee.\n     */\n    maxFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The transaction data.\n     */\n    data?: null | string;\n\n    /**\n     *  The transaction value (in wei).\n     */\n    value?: null | BigNumberish;\n\n    /**\n     *  The chain ID for the network this transaction is valid on.\n     */\n    chainId?: null | BigNumberish;\n\n    /**\n     *  The [[link-eip-2930]] access list. Storage slots included in the access\n     *  list are //warmed// by pre-loading them, so their initial cost to\n     *  fetch is guaranteed, but then each additional access is cheaper.\n     */\n    accessList?: null | AccessListish;\n\n    /**\n     *  A custom object, which can be passed along for network-specific\n     *  values.\n     */\n    customData?: any;\n\n    // Only meaningful when used for call\n\n    /**\n     *  When using ``call`` or ``estimateGas``, this allows a specific\n     *  block to be queried. Many backends do not support this and when\n     *  unsupported errors are silently squelched and ``\"latest\"`` is used. \n     */\n    blockTag?: BlockTag;\n\n    /**\n     *  When using ``call``, this enables CCIP-read, which permits the\n     *  provider to be redirected to web-based content during execution,\n     *  which is then further validated by the contract.\n     *\n     *  There are potential security implications allowing CCIP-read, as\n     *  it could be used to expose the IP address or user activity during\n     *  the fetch to unexpected parties.\n     */\n    enableCcipRead?: boolean;\n\n    // Todo?\n    //gasMultiplier?: number;\n};\n\n/**\n *  A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]\n *  except all the property types are strictly enforced.\n */\nexport interface PreparedTransactionRequest {\n    /**\n     *  The transaction type.\n     */\n    type?: number;\n\n\n    /**\n     *  The target of the transaction.\n     */\n    to?: AddressLike;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: AddressLike;\n\n    /**\n     *  The nonce of the transaction, used to prevent replay attacks.\n     */\n\n    nonce?: number;\n\n    /**\n     *  The maximum amount of gas to allow this transaction to consime.\n     */\n    gasLimit?: bigint;\n\n    /**\n     *  The gas price to use for legacy transactions or transactions on\n     *  legacy networks.\n     *\n     *  Most of the time the ``max*FeePerGas`` is preferred.\n     */\n    gasPrice?: bigint;\n\n    /**\n     *  The [[link-eip-1559]] maximum priority fee to pay per gas.\n     */\n    maxPriorityFeePerGas?: bigint;\n\n    /**\n     *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual\n     *  value used is protocol enforced to be the block's base fee.\n     */\n    maxFeePerGas?: bigint;\n\n    /**\n     *  The transaction data.\n     */\n    data?: string;\n\n\n    /**\n     *  The transaction value (in wei).\n     */\n    value?: bigint;\n\n    /**\n     *  The chain ID for the network this transaction is valid on.\n     */\n    chainId?: bigint;\n\n    /**\n     *  The [[link-eip-2930]] access list. Storage slots included in the access\n     *  list are //warmed// by pre-loading them, so their initial cost to\n     *  fetch is guaranteed, but then each additional access is cheaper.\n     */\n    accessList?: AccessList;\n\n    /**\n     *  A custom object, which can be passed along for network-specific\n     *  values.\n     */\n    customData?: any;\n\n\n\n    /**\n     *  When using ``call`` or ``estimateGas``, this allows a specific\n     *  block to be queried. Many backends do not support this and when\n     *  unsupported errors are silently squelched and ``\"latest\"`` is used. \n     */\n    blockTag?: BlockTag;\n\n    /**\n     *  When using ``call``, this enables CCIP-read, which permits the\n     *  provider to be redirected to web-based content during execution,\n     *  which is then further validated by the contract.\n     *\n     *  There are potential security implications allowing CCIP-read, as\n     *  it could be used to expose the IP address or user activity during\n     *  the fetch to unexpected parties.\n     */\n    enableCcipRead?: boolean;\n}\n\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nexport function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify(req.data); }\n\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || (<any>req)[key] == null) { continue; }\n        result[key] = getBigInt((<any>req)[key], `request.${ key }`);\n    }\n\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || (<any>req)[key] == null) { continue; }\n        result[key] = getNumber((<any>req)[key], `request.${ key }`);\n    }\n\n    if (req.accessList) {\n        result.accessList = accessListify(req.accessList);\n    }\n\n    if (\"blockTag\" in req) { result.blockTag = req.blockTag; }\n\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead\n    }\n\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n\n    return result;\n}\n\n//////////////////////\n// Block\n\n/**\n *  An Interface to indicate a [[Block]] has been included in the\n *  blockchain. This asserts a Type Guard that necessary properties\n *  are non-null.\n *\n *  Before a block is included, it is a //pending// block.\n */\nexport interface MinedBlock extends Block {\n    /**\n     *  The block number also known as the block height.\n     */\n    readonly number: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash: string;\n\n    /**\n     *  The block timestamp, in seconds from epoch.\n     */\n    readonly timestamp: number;\n\n    /**\n     *  The block date, created from the [[timestamp]].\n     */\n    readonly date: Date;\n\n    /**\n     *  The miner of the block, also known as the ``author`` or\n     *  block ``producer``.\n     */\n    readonly miner: string;\n}\n\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block implements BlockParams, Iterable<string> {\n\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    readonly number!: number;\n\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    readonly timestamp!: number;\n\n    /**\n     *  The block hash of the parent block.\n     */\n    readonly parentHash!: string;\n\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    readonly nonce!: string;\n\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    readonly difficulty!: bigint;\n\n\n    /**\n     *  The total gas limit for this block.\n     */\n    readonly gasLimit!: bigint;\n\n    /**\n     *  The total gas used in this block.\n     */\n    readonly gasUsed!: bigint;\n\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    readonly miner!: string;\n\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    readonly extraData!: string;\n\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    readonly baseFeePerGas!: null | bigint;\n\n    readonly #transactions: Array<string | TransactionResponse>;\n\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block: BlockParams, provider: Provider) {\n\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof(tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n\n        defineProperties<Block>(this, {\n            provider,\n\n            hash: getValue(block.hash),\n\n            number: block.number,\n            timestamp: block.timestamp,\n\n            parentHash: block.parentHash,\n\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions(): ReadonlyArray<string> {\n        return this.#transactions.map((tx) => {\n            if (typeof(tx) === \"string\") { return tx; }\n            return tx.hash;\n        });\n    }\n\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions(): Array<TransactionResponse> {\n        const txs = this.#transactions.slice();\n\n        // Doesn't matter...\n        if (txs.length === 0) { return [ ]; }\n\n        // Make sure we prefetched the transactions\n        assert(typeof(txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n\n        return <Array<TransactionResponse>>txs;\n    }\n\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON(): any {\n        const {\n            baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash,\n            miner, nonce, number, parentHash, timestamp, transactions\n        } = this;\n\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash, miner, nonce, number, parentHash, timestamp,\n            transactions,\n        };\n    }\n\n    [Symbol.iterator](): Iterator<string> {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The number of transactions in this block.\n     */\n    get length(): number { return this.#transactions.length; }\n\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date(): null | Date {\n        if (this.timestamp == null) { return null; }\n        return new Date(this.timestamp * 1000);\n    }\n\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash: number | string): Promise<TransactionResponse> {\n        // Find the internal value by its index or hash\n        let tx: string | TransactionResponse | undefined = undefined;\n        if (typeof(indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof(v) === \"string\") {\n                    if (v !== hash) { continue; }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash === hash) { continue; }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) { throw new Error(\"no such tx\"); }\n\n        if (typeof(tx) === \"string\") {\n            return <TransactionResponse>(await this.provider.getTransaction(tx));\n        } else {\n            return tx;\n        }\n    }\n\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash: number | string): TransactionResponse {\n        const txs = this.prefetchedTransactions;\n        if (typeof(indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) { return tx; }\n        }\n\n        assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined(): this is MinedBlock { return !!this.hash; }\n\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon(): this is (Block & { baseFeePerGas: bigint }) {\n        return !!this.baseFeePerGas;\n    }\n\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent(): OrphanFilter {\n        if (!this.isMined()) { throw new Error(\"\"); }\n        return createOrphanedBlockFilter(this);\n    }\n}\n\n//////////////////////\n// Log\n\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nexport class Log implements LogParams {\n\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    readonly transactionHash!: string;\n\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    readonly blockHash!: string;\n\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    readonly blockNumber!: number;\n\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    readonly removed!: boolean;\n\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    readonly address!: string;\n\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    readonly data!: string;\n\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    readonly topics!: ReadonlyArray<string>;\n\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    readonly index!: number;\n\n    /**\n     *  The index within the transaction of this log.\n     */\n    readonly transactionIndex!: number;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(log: LogParams, provider: Provider) {\n        this.provider = provider;\n\n        const topics = Object.freeze(log.topics.slice());\n        defineProperties<Log>(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n\n            removed: log.removed,\n\n            address: log.address,\n            data: log.data,\n\n            topics,\n\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON(): any {\n        const {\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        } = this;\n\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock(): Promise<Block> {\n        const block = await this.provider.getBlock(this.blockHash);\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", { });\n        return block;\n    }\n\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction(): Promise<TransactionResponse> {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", { });\n        return tx;\n    }\n\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt(): Promise<TransactionReceipt> {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", { });\n        return receipt;\n    }\n\n    /**\n     *  @_ignore:\n     */\n    removedEvent(): OrphanFilter {\n        return createRemovedLogFilter(this);\n    }\n}\n\n//////////////////////\n// Transaction Receipt\n\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nexport class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The address the transaction was sent to.\n     */\n    readonly to!: null | string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    readonly from!: string;\n\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    readonly contractAddress!: null | string;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash!: string;\n\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    readonly index!: number;\n\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    readonly blockHash!: string;\n\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    readonly blockNumber!: number;\n\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    readonly logsBloom!: string;\n\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    readonly gasUsed!: bigint;\n\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    readonly cumulativeGasUsed!: bigint;\n\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    readonly gasPrice!: bigint;\n\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    readonly type!: number;\n    //readonly byzantium!: boolean;\n\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    readonly status!: null | number;\n\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    readonly root!: null | string;\n\n    readonly #logs: ReadonlyArray<Log>;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(tx: TransactionReceiptParams, provider: Provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n\n        defineProperties<TransactionReceipt>(this, {\n            provider,\n\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n\n            hash: tx.hash,\n            index: tx.index,\n\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n\n            logsBloom: tx.logsBloom,\n\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice,\n\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n\n    /**\n     *  The logs for this transaction.\n     */\n    get logs(): ReadonlyArray<Log> { return this.#logs; }\n\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON(): any {\n        const {\n            to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom,\n            logs, //byzantium, \n            status, root\n        } = this;\n\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n\n    /**\n     *  @_ignore:\n     */\n    get length(): number { return this.logs.length; }\n\n    [Symbol.iterator](): Iterator<Log> {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee(): bigint {\n        return this.gasUsed * this.gasPrice;\n    }\n\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock(): Promise<Block> {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) { throw new Error(\"TODO\"); }\n        return block;\n    }\n\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction(): Promise<TransactionResponse> {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) { throw new Error(\"TODO\"); }\n        return tx;\n    }\n\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult(): Promise<string> {\n        return <string>(await this.provider.getTransactionResult(this.hash));\n    }\n\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations(): Promise<number> {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n\n    /**\n     *  @_ignore:\n     */\n    removedEvent(): OrphanFilter {\n        return createRemovedTransactionFilter(this);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other?: TransactionResponse): OrphanFilter {\n        assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n\n\n//////////////////////\n// Transaction Response\n\n/**\n *  A **MinedTransactionResponse** is an interface representing a\n *  transaction which has been mined and allows for a type guard for its\n *  property values being defined.\n */\nexport interface MinedTransactionResponse extends TransactionResponse {\n    /**\n     *  The block number this transaction occurred in.\n     */\n    blockNumber: number;\n\n    /**\n     *  The block hash this transaction occurred in.\n     */\n    blockHash: string;\n\n    /**\n     *  The date this transaction occurred on.\n     */\n    date: Date;\n}\n\n\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nexport class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    readonly blockNumber: null | number;\n\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    readonly blockHash: null | string;\n\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    readonly index!: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash!: string;\n\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    readonly type!: number;\n\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    readonly to!: null | string;\n\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    readonly from!: string;\n\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    readonly nonce!: number;\n\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    readonly gasLimit!: bigint;\n\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    readonly gasPrice!: bigint;\n\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    readonly maxPriorityFeePerGas!: null | bigint;\n\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    readonly maxFeePerGas!: null | bigint;\n\n    /**\n     *  The data.\n     */\n    readonly data!: string;\n\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    readonly value!: bigint;\n\n    /**\n     *  The chain ID.\n     */\n    readonly chainId!: bigint;\n\n    /**\n     *  The signature.\n     */\n    readonly signature!: Signature;\n\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    readonly accessList!: null | AccessList;\n\n    #startBlock: number;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(tx: TransactionResponseParams, provider: Provider) {\n        this.provider = provider;\n\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber: null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash: null;\n\n        this.hash = tx.hash;\n        this.index = tx.index;\n\n        this.type = tx.type;\n\n        this.from = tx.from;\n        this.to = tx.to || null;\n\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas: null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas: null;\n\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n\n        this.accessList = (tx.accessList != null) ? tx.accessList: null;\n\n        this.#startBlock = -1;\n    }\n\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON(): any {\n        const {\n            blockNumber, blockHash, index, hash, type, to, from, nonce,\n            data, signature, accessList\n        } = this;\n\n        return {\n            _type: \"TransactionReceipt\",\n            accessList, blockNumber, blockHash,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock(): Promise<null | Block> {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) { blockNumber = tx.blockNumber; }\n        }\n        if (blockNumber == null) { return null; }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) { throw new Error(\"TODO\"); }\n        return block;\n    }\n\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction(): Promise<null | TransactionResponse> {\n        return this.provider.getTransaction(this.hash);\n    }\n\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations(): Promise<number> {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await resolveProperties({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) { return 0; }\n\n            return blockNumber - tx.blockNumber + 1;\n        }\n\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms?: number, _timeout?: number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms == null) ? 1: _confirms;\n        const timeout = (_timeout == null) ? 0: _timeout;\n\n        let startBlock = this.#startBlock\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true: false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) { return null; }\n            const { blockNumber, nonce } = await resolveProperties({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n\n            // We were mined; no replacement\n            if (stopScanning) { return null; }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) { return; }\n\n            // We were replaced; start scanning for that transaction\n\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) { nextScan = this.#startBlock; }\n            }\n\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) { return null; }\n                const block = await this.provider.getBlock(nextScan, true);\n\n                // This should not happen; but we'll try again shortly\n                if (block == null) { return; }\n\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) { return; }\n                }\n\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx: TransactionResponse = await block.getTransaction(i);\n\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) { return null; }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) { return; }\n\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) { return; }\n\n                        // The reason we were replaced\n                        let reason: \"replaced\" | \"repriced\" | \"cancelled\" = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\"\n                        }\n\n                        assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n\n                nextScan++;\n            }\n            return;\n        };\n\n        const checkReceipt = (receipt: null | TransactionReceipt) => {\n            if (receipt == null || receipt.status !== 0) { return receipt; }\n            assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n\n        if (confirms === 0) { return checkReceipt(receipt); }\n\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n\n            // Allow null only when the confirms is 0\n            if (confirms === 0) { return null; }\n        }\n\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers: Array<() => void> = [ ];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n\n            const txListener = async (receipt: TransactionReceipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) { reject(error); }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n\n        return await <Promise<TransactionReceipt>>waiter;\n    }\n\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined(): this is MinedTransactionResponse {\n        return (this.blockHash != null);\n    }\n\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy(): this is (TransactionResponse & { accessList: null, maxFeePerGas: null, maxPriorityFeePerGas: null }) {\n        return (this.type === 0)\n    }\n\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin(): this is (TransactionResponse & { accessList: AccessList, maxFeePerGas: null, maxPriorityFeePerGas: null }) {\n        return (this.type === 1);\n    }\n\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon(): this is (TransactionResponse & { accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint }){\n        return (this.type === 2);\n    }\n\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent(): OrphanFilter {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other?: TransactionResponse): OrphanFilter {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n\n        assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n\n        return createReorderedTransactionFilter(this, other);\n    }\n\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock: number): TransactionResponse {\n        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\n\n\n//////////////////////\n// OrphanFilter\n\n/**\n *  An Orphan Filter allows detecting when an orphan block has\n *  resulted in dropping a block or transaction or has resulted\n *  in transactions changing order.\n *\n *  Not currently fully supported.\n */\nexport type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"drop-log\",\n    log: {\n        transactionHash: string,\n        blockHash: string,\n        blockNumber: number,\n        address: string,\n        data: string,\n        topics: ReadonlyArray<string>,\n        index: number\n    }\n};\n\nfunction createOrphanedBlockFilter(block: { hash: string, number: number }): OrphanFilter {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\n\nfunction createReorderedTransactionFilter(tx: { hash: string, blockHash: string, blockNumber: number }, other?: { hash: string, blockHash: string, blockNumber: number }): OrphanFilter {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\n\nfunction createRemovedTransactionFilter(tx: { hash: string, blockHash: string, blockNumber: number }): OrphanFilter {\n    return { orphan: \"drop-transaction\", tx };\n}\n\nfunction createRemovedLogFilter(log: { blockHash: string, transactionHash: string, blockNumber: number, address: string, data: string, topics: ReadonlyArray<string>, index: number }): OrphanFilter {\n    return { orphan: \"drop-log\", log: {\n        transactionHash: log.transactionHash,\n        blockHash: log.blockHash,\n        blockNumber: log.blockNumber,\n        address: log.address,\n        data: log.data,\n        topics: Object.freeze(log.topics.slice()),\n        index: log.index\n    } };\n}\n\n//////////////////////\n// EventFilter\n\n/**\n *  A **TopicFilter** provides a struture to define bloom-filter\n *  queries.\n *\n *  Each field that is ``null`` matches **any** value, a field that is\n *  a ``string`` must match exactly that value and and ``array`` is\n *  effectively an ``OR``-ed set, where any one of those values must\n *  match.\n */\nexport type TopicFilter = Array<null | string | Array<string>>;\n\n// @TODO:\n//export type DeferableTopicFilter = Array<null | string | Promise<string> | Array<string | Promise<string>>>;\n\n/**\n *  An **EventFilter** allows efficiently filtering logs (also known as\n *  events) using bloom filters included within blocks.\n */\nexport interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}\n\n/**\n *  A **Filter** allows searching a specific range of blocks for mathcing\n *  logs.\n */\nexport interface Filter extends EventFilter {\n\n    /**\n     *  The start block for the filter (inclusive).\n     */\n    fromBlock?: BlockTag;\n\n    /**\n     *  The end block for the filter (inclusive).\n     */\n    toBlock?: BlockTag;\n}\n\n/**\n *  A **FilterByBlockHash** allows searching a specific block for mathcing\n *  logs.\n */\nexport interface FilterByBlockHash extends EventFilter {\n    /**\n     *  The blockhash of the specific block for the filter.\n     */\n    blockHash?: string;\n}\n\n\n//////////////////////\n// ProviderEvent\n\n/**\n *  A **ProviderEvent** provides the types of events that can be subscribed\n *  to on a [[Provider]].\n *\n *  Each provider may include additional possible events it supports, but\n *  the most commonly supported are:\n *\n *  **``\"block\"``** - calls the listener with the current block number on each\n *  new block.\n *\n *  **``\"error\"``** - calls the listener on each async error that occurs during\n *  the event loop, with the error.\n *\n *  **``\"debug\"``** - calls the listener on debug events, which can be used to\n *  troubleshoot network errors, provider problems, etc.\n *\n *  **``transaction hash``** - calls the listener on each block after the\n *  transaction has been mined; generally ``.once`` is more appropriate for\n *  this event.\n *\n *  **``Array``** - calls the listener on each log that matches the filter.\n *\n *  [[EventFilter]] - calls the listener with each matching log\n */\nexport type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;\n\n\n//////////////////////\n// Provider\n\n/**\n *  A **Provider** is the primary method to interact with the read-only\n *  content on Ethereum.\n *\n *  It allows access to details about accounts, blocks and transactions\n *  and the ability to query event logs and simulate contract execution.\n *\n *  Account data includes the [balance](getBalance),\n *  [transaction count](getTransactionCount), [code](getCode) and\n *  [state trie storage](getStorage).\n *\n *  Simulating execution can be used to [call](call),\n *  [estimate gas](estimateGas) and\n *  [get transaction results](getTransactionResult).\n *\n *  The [[broadcastTransaction]] is the only method which allows updating\n *  the blockchain, but it is usually accessed by a [[Signer]], since a\n *  private key must be used to sign the transaction before it can be\n *  broadcast.\n */\nexport interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be used to access the read-only portion of the runner.\n     */\n    provider: this;\n\n    /**\n     *  Shutdown any resources this provider is using. No additional\n     *  calls should be made to this provider after calling this.\n     */\n    destroy(): void;\n\n    ////////////////////\n    // State\n\n    /**\n     *  Get the current block number.\n     */\n    getBlockNumber(): Promise<number>;\n\n    /**\n     *  Get the connected [[Network]].\n     */\n    getNetwork(): Promise<Network>;\n\n    /**\n     *  Get the best guess at the recommended [[FeeData]].\n     */\n    getFeeData(): Promise<FeeData>;\n\n\n    ////////////////////\n    // Account\n\n    /**\n     *  Get the account balance (in wei) of %%address%%. If %%blockTag%%\n     *  is specified and the node supports archive access for that\n     *  %%blockTag%%, the balance is as of that [[BlockTag]].\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint>;\n\n    /**\n     *  Get the number of transactions ever sent for %%address%%, which\n     *  is used as the ``nonce`` when sending a transaction. If\n     *  %%blockTag%% is specified and the node supports archive access\n     *  for that %%blockTag%%, the transaction count is as of that\n     *  [[BlockTag]].\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number>;\n\n    /**\n     *  Get the bytecode for %%address%%.\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getCode(address: AddressLike, blockTag?: BlockTag): Promise<string>\n\n    /**\n     *  Get the storage slot value for %%address%% at slot %%position%%.\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getStorage(address: AddressLike, position: BigNumberish, blockTag?: BlockTag): Promise<string>\n\n\n    ////////////////////\n    // Execution\n\n    /**\n     *  Estimates the amount of gas required to executre %%tx%%.\n     */\n    estimateGas(tx: TransactionRequest): Promise<bigint>;\n\n    /**\n     *  Simulate the execution of %%tx%%. If the call reverts, it will\n     *  throw a [[CallExceptionError]] which includes the revert data.\n     */\n    call(tx: TransactionRequest): Promise<string>\n\n    /**\n     *  Broadcasts the %%signedTx%% to the network, adding it to the\n     *  memory pool of any node for which the transaction meets the\n     *  rebroadcast requirements.\n     */\n    broadcastTransaction(signedTx: string): Promise<TransactionResponse>;\n\n\n    ////////////////////\n    // Queries\n\n    /**\n     *  Resolves to the block for %%blockHashOrBlockTag%%.\n     *\n     *  If %%prefetchTxs%%, and the backend supports including transactions\n     *  with block requests, all transactions will be included and the\n     *  [[Block]] object will not need to make remote calls for getting\n     *  transactions.\n     */\n    getBlock(blockHashOrBlockTag: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block>;\n\n    /**\n     *  Resolves to the transaction for %%hash%%.\n     *\n     *  If the transaction is unknown or on pruning nodes which\n     *  discard old transactions this resolves to ``null``.\n     */\n    getTransaction(hash: string): Promise<null | TransactionResponse>;\n\n    /**\n     *  Resolves to the transaction receipt for %%hash%%, if mined.\n     *\n     *  If the transaction has not been mined, is unknown or on\n     *  pruning nodes which discard old transactions this resolves to\n     *  ``null``.\n     */\n    getTransactionReceipt(hash: string): Promise<null | TransactionReceipt>;\n\n    /**\n     *  Resolves to the result returned by the executions of %%hash%%.\n     *\n     *  This is only supported on nodes with archive access and with\n     *  the necessary debug APIs enabled.\n     */\n    getTransactionResult(hash: string): Promise<null | string>;\n\n\n    ////////////////////\n    // Bloom-filter Queries\n\n    /**\n     *  Resolves to the list of Logs that match %%filter%%\n     */\n    getLogs(filter: Filter | FilterByBlockHash): Promise<Array<Log>>;\n\n\n    ////////////////////\n    // ENS\n\n    /**\n     *  Resolves to the address configured for the %%ensName%% or\n     *  ``null`` if unconfigured.\n     */\n    resolveName(ensName: string): Promise<null | string>;\n\n    /**\n     *  Resolves to the ENS name associated for the %%address%% or\n     *  ``null`` if the //primary name// is not configured.\n     *\n     *  Users must perform additional steps to configure a //primary name//,\n     *  which is not currently common.\n     */\n    lookupAddress(address: string): Promise<null | string>;\n\n    /**\n     *  Waits until the transaction %%hash%% is mined and has %%confirms%%\n     *  confirmations.\n     */\n    waitForTransaction(hash: string, confirms?: number, timeout?: number): Promise<null | TransactionReceipt>;\n\n    /**\n     *  Resolves to the block at %%blockTag%% once it has been mined.\n     *\n     *  This can be useful for waiting some number of blocks by using\n     *  the ``currentBlockNumber + N``.\n     */\n    waitForBlock(blockTag?: BlockTag): Promise<Block>;\n}\n", "// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport {\n    Block, Log, TransactionReceipt, TransactionResponse\n} from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n\nimport type { EventFragment, Interface, Result } from \"../abi/index.js\";\nimport type { Listener } from \"../utils/index.js\";\nimport type {\n    Provider\n} from \"../providers/index.js\";\n\nimport type { BaseContract } from \"./contract.js\";\nimport type { ContractEventName } from \"./types.js\";\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The matching event.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    readonly args!: Result;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, iface: Interface, fragment: EventFragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        defineProperties<EventLog>(this, { args, fragment, interface: iface });\n    }\n\n    /**\n     *  The name of the event.\n     */\n    get eventName(): string { return this.fragment.name; }\n\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature(): string { return this.fragment.format(); }\n}\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class UndecodedEventLog extends Log {\n\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    readonly error!: Error;\n\n    /**\n     * @_ignore:\n     */\n    constructor(log: Log, error: Error) {\n        super(log, log.provider);\n        defineProperties<UndecodedEventLog>(this, { error });\n    }\n}\n\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nexport class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs(): Array<EventLog | Log> {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]): null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment)\n                } catch (error: any) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n\n            return log;\n        });\n    }\n\n}\n\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nexport class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms?: number): Promise<null | ContractTransactionReceipt> {\n        const receipt = await super.wait(confirms);\n        if (receipt == null) { return null; }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nexport  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    /**\n     *  The log with no matching events.\n     */\n    readonly log!: Log;\n\n    /**\n     *  @_event:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Log) {\n        super(contract, listener, filter);\n        defineProperties<ContractUnknownEventPayload>(this, { log });\n    }\n\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock(): Promise<Block> {\n        return await this.log.getBlock();\n    }\n\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction(): Promise<TransactionResponse> {\n        return await this.log.getTransaction();\n    }\n\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt(): Promise<TransactionReceipt> {\n        return await this.log.getTransactionReceipt();\n    }\n}\n\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n\n    /**\n     *  The matching event.\n     */\n    declare readonly fragment: EventFragment;\n\n    /**\n     *  The log, with parsed properties.\n     */\n    declare readonly log: EventLog;\n\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    declare readonly args: Result;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, fragment: EventFragment, _log: Log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        defineProperties<ContractEventPayload>(this, { args, fragment });\n    }\n\n    /**\n     *  The event name.\n     */\n    get eventName(): string {\n        return this.fragment.name;\n    }\n\n    /**\n     *  The event signature.\n     */\n    get eventSignature(): string {\n        return this.fragment.format();\n    }\n}\n", "import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, getBigInt, isCallException, isHexString, resolveProperties,\n    isError, makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog, UndecodedEventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable, NameResolver } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nfunction getResolver(value: any): undefined | NameResolver {\n    if (value != null) {\n        if (canResolve(value)) { return value; }\n        if (value.provider) { return value.provider; }\n    }\n    return undefined;\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));\n                        }\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = Typed.dereference(arg, \"overrides\");\n    assertArgument(typeof(_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(_overrides);\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) { overrides.from = overrides.from; }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        if (tx.from) {\n            tx.from = await resolveAddress(tx.from, getResolver(contract.runner));\n        }\n\n        const iface = contract.interface;\n\n        const noValue = (getBigInt((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || noValue,\n          \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n\n            if (overrides.from) {\n                overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));\n            }\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    readonly target!: string | Addressable;\n\n    /**\n     *  The contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    readonly runner!: null | ContractRunner;\n\n    /**\n     *  All the Events available on this contract.\n     */\n    readonly filters!: Record<string, ContractEvent>;\n\n    /**\n     *  @_ignore:\n     */\n    readonly [internal]: any;\n\n    /**\n     *  The fallback or receive function if any.\n     */\n    readonly fallback!: null | WrappedFallback;\n\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        assertArgument(typeof(target) === \"string\" || isAddressable(target),\n            \"invalid value for Contract target\", \"target\", target);\n\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr: null | string = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof(prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof(prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return target.interface.hasFunction(prop);\n            }\n        });\n\n    }\n\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target: string | Addressable): BaseContract {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        throw new Error(\"@TODO\");\n    }\n\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                try {\n                    return new EventLog(log, this.interface, foundFragment);\n                } catch (error: any) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n\n            return new Log(log, provider);\n        });\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass<T = ContractInterface>(abi: Interface | InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from<T = ContractInterface>(target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() { }\n", "import {\n  verifyMessage as ethersVerifyMessage,\n  hashMessage as ethersHashMessage,\n  getAddress as ethersGetAddress,\n} from 'ethers';\n\ntype Ethers6BigNumberish = string | number | bigint;\n\n// NB: This compatibility type omits the `Signature` class defined in ethers v6;\n// however, a `Signature` instance is compatible with the object type defined.\ntype Ethers6SignatureLike =\n  | string\n  | {\n      r: string;\n      s: string;\n      v: Ethers6BigNumberish;\n      yParity?: 0 | 1;\n      yParityAndS?: string;\n    }\n  | {\n      r: string;\n      yParityAndS: string;\n      yParity?: 0 | 1;\n      s?: string;\n      v?: number;\n    }\n  | {\n      r: string;\n      s: string;\n      yParity: 0 | 1;\n      v?: Ethers6BigNumberish;\n      yParityAndS?: string;\n    };\n\nexport const verifyMessage = ethersVerifyMessage as (\n  message: Uint8Array | string,\n  sig: Ethers6SignatureLike\n) => string;\n\nexport const hashMessage = ethersHashMessage as (\n  message: Uint8Array | string\n) => string;\n\nexport const getAddress = ethersGetAddress as (address: string) => string;\n", "import { Provider } from 'ethers';\nimport { SiweMessage } from './client';\n\nexport interface VerifyParams {\n  /** Signature of the message signed by the wallet */\n  signature: string;\n\n  /** RFC 4501 dns authority that is requesting the signing. */\n  domain?: string;\n\n  /** Randomized token used to prevent replay attacks, at least 8 alphanumeric characters. */\n  nonce?: string;\n\n  /**ISO 8601 datetime string of the current time. */\n  time?: string;\n}\n\nexport const VerifyParamsKeys: Array<keyof VerifyParams> = [\n  'signature',\n  'domain',\n  'nonce',\n  'time',\n];\n\nexport interface VerifyOpts {\n  /** ethers provider to be used for EIP-1271 validation */\n  provider?: Provider;\n\n  /** If the library should reject promises on errors, defaults to false */\n  suppressExceptions?: boolean;\n\n  /** Enables a custom verification function that will be ran alongside EIP-1271 check. */\n  verificationFallback?: (\n    params: VerifyParams,\n    opts: VerifyOpts,\n    message: SiweMessage,\n    EIP1271Promise: Promise<SiweResponse>\n  ) => Promise<SiweResponse>;\n}\n\nexport const VerifyOptsKeys: Array<keyof VerifyOpts> = [\n  'provider',\n  'suppressExceptions',\n  'verificationFallback',\n];\n\n/**\n * Returned on verifications.\n */\nexport interface SiweResponse {\n  /** Boolean representing if the message was verified with success. */\n  success: boolean;\n\n  /** If present `success` MUST be false and will provide extra information on the failure reason. */\n  error?: SiweError;\n\n  /** Original message that was verified. */\n  data: SiweMessage;\n}\n\n/**\n * Interface used to return errors in SiweResponses.\n */\nexport class SiweError {\n  constructor(\n    type: SiweErrorType | string,\n    expected?: string,\n    received?: string\n  ) {\n    this.type = type;\n    this.expected = expected;\n    this.received = received;\n  }\n\n  /** Type of the error. */\n  type: SiweErrorType | string;\n\n  /** Expected value or condition to pass. */\n  expected?: string;\n\n  /** Received value that caused the failure. */\n  received?: string;\n}\n\n/**\n * Possible message error types.\n */\nexport enum SiweErrorType {\n  /** `expirationTime` is present and in the past. */\n  EXPIRED_MESSAGE = 'Expired message.',\n\n  /** `domain` is not a valid authority or is empty. */\n  INVALID_DOMAIN = 'Invalid domain.',\n\n  /** `domain` don't match the domain provided for verification. */\n  DOMAIN_MISMATCH = 'Domain does not match provided domain for verification.',\n\n  /** `nonce` don't match the nonce provided for verification. */\n  NONCE_MISMATCH = 'Nonce does not match provided nonce for verification.',\n\n  /** `address` does not conform to EIP-55 or is not a valid address. */\n  INVALID_ADDRESS = 'Invalid address.',\n\n  /** `uri` does not conform to RFC 3986. */\n  INVALID_URI = 'URI does not conform to RFC 3986.',\n\n  /** `nonce` is smaller then 8 characters or is not alphanumeric */\n  INVALID_NONCE = 'Nonce size smaller then 8 characters or is not alphanumeric.',\n\n  /** `notBefore` is present and in the future. */\n  NOT_YET_VALID_MESSAGE = 'Message is not valid yet.',\n\n  /** Signature doesn't match the address of the message. */\n  INVALID_SIGNATURE = 'Signature does not match address of the message.',\n\n  /** `expirationTime`, `notBefore` or `issuedAt` not complient to ISO-8601. */\n  INVALID_TIME_FORMAT = 'Invalid time format.',\n\n  /** `version` is not 1. */\n  INVALID_MESSAGE_VERSION = 'Invalid message version.',\n\n  /** Thrown when some required field is missing. */\n  UNABLE_TO_PARSE = 'Unable to parse the message.',\n}\n", "import { randomStringForEntropy } from '@stablelib/random';\nimport { Contract, Provider, Signer } from 'ethers';\n\nimport type { SiweMessage } from './client';\nimport { hashMessage } from './ethersCompat';\n\nconst EIP1271_ABI = [\n  'function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)',\n];\nconst EIP1271_MAGICVALUE = '0x1626ba7e';\nconst ISO8601 =\n  /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n\n/**\n * This method calls the EIP-1271 method for Smart Contract wallets\n * @param message The EIP-4361 parsed message\n * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).\n * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if\n * the signature is valid for given address.\n */\nexport const checkContractWalletSignature = async (\n  message: SiweMessage,\n  signature: string,\n  provider?: Provider | Signer\n): Promise<boolean> => {\n  if (!provider) {\n    return false;\n  }\n\n  const walletContract = new Contract(message.address, EIP1271_ABI, provider);\n  const hashedMessage = hashMessage(message.prepareMessage());\n  const res = await walletContract.isValidSignature(hashedMessage, signature);\n  return res === EIP1271_MAGICVALUE;\n};\n\n/**\n * This method leverages a native CSPRNG with support for both browser and Node.js\n * environments in order generate a cryptographically secure nonce for use in the\n * SiweMessage in order to prevent replay attacks.\n *\n * 96 bits has been chosen as a number to sufficiently balance size and security considerations\n * relative to the lifespan of it's usage.\n *\n * @returns cryptographically generated random nonce with 96 bits of entropy encoded with\n * an alphanumeric character set.\n */\nexport const generateNonce = (): string => {\n  const nonce = randomStringForEntropy(96);\n  if (!nonce || nonce.length < 8) {\n    throw new Error('Error during nonce creation.');\n  }\n  return nonce;\n};\n\n/**\n * This method matches the given date string against the ISO-8601 regex and also\n * performs checks if it's a valid date.\n * @param inputDate any string to be validated against ISO-8601\n * @returns boolean indicating if the providade date is valid and conformant to ISO-8601\n */\nexport const isValidISO8601Date = (inputDate: string): boolean => {\n  /* Split groups and make sure inputDate is in ISO8601 format */\n  const inputMatch = ISO8601.exec(inputDate);\n\n  /* if inputMatch is null the date is not ISO-8601 */\n  if (!inputDate) {\n    return false;\n  }\n\n  /* Creates a date object with input date to parse for invalid days e.g. Feb, 30 -> Mar, 01 */\n  const inputDateParsed = new Date(inputMatch.groups.date).toISOString();\n\n  /* Get groups from new parsed date to compare with the original input */\n  const parsedInputMatch = ISO8601.exec(inputDateParsed);\n\n  /* Compare remaining fields */\n  return inputMatch.groups.date === parsedInputMatch.groups.date;\n};\n\nexport const checkInvalidKeys = <T>(\n  obj: T,\n  keys: Array<keyof T>\n): Array<keyof T> => {\n  const invalidKeys: Array<keyof T> = [];\n  Object.keys(obj).forEach(key => {\n    if (!keys.includes(key as keyof T)) {\n      invalidKeys.push(key as keyof T);\n    }\n  });\n  return invalidKeys;\n};\n"],
  "mappings": "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AAa,YACb,YAAa,YACb,cAAe,cACf,YAAa,YACb,gBAAiB,iBACjB,iBAAkB,WACpB,ICvBA,IAAAC,GAAAC,GAAAC,IAAA,eAYA,GAAM,CAAE,OAAAC,EAAO,EAAI,KAGbC,GAAe,WACfC,GAAW,WACXC,GAAQ,WACRC,GAAa,WAGbC,GAAO,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAI,EAGnDC,GAAQ,CACZ,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,EAGMC,GAAc,oEAAoE,MAAM,EAAE,EAG1FC,GAAc,CAAC,EACrBD,GAAY,QAASE,GAAS,CAC5BD,GAAY,KAAKC,EAAK,WAAW,CAAC,CAAC,CACrC,CAAC,EAGDV,GAAQ,KAAO,CACb,OAAOW,EAAO,CACZ,IAAMC,EAAQ,CAAC,EACf,OAAAD,EAAM,QAASD,GAAS,CACtB,GAAIA,GAAQ,GAAKA,GAAQ,IACvBE,EAAM,KAAKF,CAAI,UACNA,GAAQ,KACjBE,EAAM,KAAK,KAASF,GAAQ,EAAKJ,GAAK,CAAC,EAAE,EACzCM,EAAM,KAAK,KAAQF,EAAOJ,GAAK,CAAC,EAAE,UACzBI,EAAO,OAAWA,EAAO,OAAUA,GAAQ,MACpDE,EAAM,KAAK,KAASF,GAAQ,GAAMJ,GAAK,CAAC,EAAE,EAC1CM,EAAM,KAAK,KAASF,GAAQ,EAAKJ,GAAK,CAAC,EAAE,EACzCM,EAAM,KAAK,KAAQF,EAAOJ,GAAK,CAAC,EAAE,UACzBI,GAAQ,OAAWA,GAAQ,QAAU,CAC9C,IAAMG,EAAKH,GAAQ,GAAMJ,GAAK,CAAC,EAC/BM,EAAM,KAAK,KAAQC,GAAK,EAAE,EAC1BD,EAAM,KAAK,MAASC,EAAIP,GAAK,CAAC,IAAM,IAAOI,GAAQ,GAAMJ,GAAK,CAAC,EAAE,EACjEM,EAAM,KAAK,KAASF,GAAQ,EAAKJ,GAAK,CAAC,EAAE,EACzCM,EAAM,KAAK,KAAQF,EAAOJ,GAAK,CAAC,EAAE,CACpC,KACE,OAAM,IAAI,WAAW,8CAA8CI,CAAI,EAAE,CAE7E,CAAC,EACMT,GAAO,KAAKW,CAAK,CAC1B,EACA,OAAOE,EAAKC,EAAK,CAEf,SAASC,EAAOC,EAAIC,EAAI,CAGtB,IAAKA,EAAK,OAAU,IAClB,OAAOf,GAET,IAAMgB,IAAMF,EAAKX,GAAK,CAAC,IAAM,IAAMY,EAAKZ,GAAK,CAAC,GAC9C,OAAIa,EAAI,IACCjB,GAEFiB,CACT,CACA,SAASC,EAAOH,EAAIC,EAAIG,EAAI,CAG1B,IAAKA,EAAK,OAAU,MAASH,EAAK,OAAU,IAC1C,OAAOf,GAET,IAAMgB,IAAMF,EAAKX,GAAK,CAAC,IAAM,MAAQY,EAAKZ,GAAK,CAAC,IAAM,IAAMe,EAAKf,GAAK,CAAC,GACvE,OAAIa,EAAI,KACCjB,GAELiB,GAAK,OAAUA,GAAK,MACff,GAEFe,CACT,CACA,SAASG,EAAOL,EAAIC,EAAIG,EAAIE,EAAI,CAG9B,IAAKA,EAAK,OAAU,MAASF,EAAK,OAAU,MAASH,EAAK,OAAU,IAClE,OAAOf,GAET,IAAMgB,KACAF,EAAKX,GAAK,CAAC,IAAM,IAAOY,GAAM,EAAKZ,GAAK,CAAC,IAAO,MAClDY,EAAKZ,GAAK,CAAC,IAAM,MACjBe,EAAKf,GAAK,CAAC,IAAM,IAClBiB,EAAKjB,GAAK,CAAC,GACd,OAAIa,EAAI,MACCjB,GAELiB,EAAI,QACCf,GAEFe,CACT,CACA,IAAIK,EACAP,EACAQ,EACAC,EACAC,EACAC,EACEC,EAAMf,EAAI,OACZgB,EAAIf,EAAM,EAAI,EACZJ,EAAQ,CAAC,EACf,KAAOmB,EAAID,GAAK,CACdZ,EAAKH,EAAIgB,CAAC,EACVN,EAAInB,GACJ,IAAM0B,EAAO,GACb,KAAOA,GAAM,CACX,GAAId,GAAM,GAAKA,GAAM,IAAM,CAEzBO,EAAIP,EACJW,EAAM,EACN,KACF,CAEA,GADAH,EAAKK,EAAI,EACLL,EAAKI,GAAOZ,GAAM,KAAQA,GAAM,IAAM,CAExCO,EAAIR,EAAOC,EAAIH,EAAIW,CAAE,CAAC,EACtBG,EAAM,EACN,KACF,CAEA,GADAF,EAAKI,EAAI,EACLJ,EAAKG,GAAOZ,GAAM,KAAQA,GAAM,IAAM,CAExCO,EAAIJ,EAAOH,EAAIH,EAAIW,CAAE,EAAGX,EAAIY,CAAE,CAAC,EAC/BE,EAAM,EACN,KACF,CAEA,GADAD,EAAKG,EAAI,EACLH,EAAKE,GAAOZ,GAAM,KAAQA,GAAM,IAAM,CAExCO,EAAIF,EAAOL,EAAIH,EAAIW,CAAE,EAAGX,EAAIY,CAAE,EAAGZ,EAAIa,CAAE,CAAC,EACxCC,EAAM,EACN,KACF,CAEA,KACF,CACA,GAAIJ,EAAI,QAAU,CAChB,IAAMQ,EAAK,QAAQF,CAAC,IACpB,MAAIN,IAAMnB,GACF,IAAI,WAAW,wDAAwD2B,CAAE,EAAE,EAE/ER,IAAMrB,GACF,IAAI,WAAW,gDAAgD6B,CAAE,EAAE,EAEvER,IAAMpB,GACF,IAAI,WAAW,kDAAkD4B,CAAE,EAAE,EAEzER,IAAMtB,GACF,IAAI,WAAW,4CAA4C8B,CAAE,EAAE,EAEjE,IAAI,WAAW,6CAA6CA,CAAE,EAAE,CACxE,CACArB,EAAM,KAAKa,CAAC,EACZM,GAAKF,CACP,CACA,OAAOjB,CACT,CACF,EAGAX,GAAQ,QAAU,CAChB,OAAOW,EAAO,CACZ,IAAMC,EAAQ,CAAC,EACXF,EACAuB,EACAC,EACJ,QAAS,EAAI,EAAG,EAAIvB,EAAM,OAAQ,GAAK,EAErC,GADAD,EAAOC,EAAM,CAAC,EACTD,GAAQ,GAAKA,GAAQ,OAAYA,GAAQ,OAAUA,GAAQ,MAC9DE,EAAM,KAAMF,GAAQ,EAAKJ,GAAK,CAAC,CAAC,EAChCM,EAAM,KAAKF,EAAOJ,GAAK,CAAC,CAAC,UAChBI,GAAQ,OAAWA,GAAQ,QACpCwB,EAAIxB,EAAO,MACXuB,EAAI,OAAUC,GAAK,IACnBA,EAAI,OAAUA,EAAI5B,GAAK,EAAE,GACzBM,EAAM,KAAMqB,GAAK,EAAK3B,GAAK,CAAC,CAAC,EAC7BM,EAAM,KAAKqB,EAAI3B,GAAK,CAAC,CAAC,EACtBM,EAAM,KAAMsB,GAAK,EAAK5B,GAAK,CAAC,CAAC,EAC7BM,EAAM,KAAKsB,EAAI5B,GAAK,CAAC,CAAC,MAEtB,OAAM,IAAI,WAAW,oDAAoD,CAAC,MAAMI,CAAI,EAAE,EAG1F,OAAOT,GAAO,KAAKW,CAAK,CAC1B,EACA,OAAOE,EAAKC,EAAK,CAEf,GAAID,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,mEAAmEA,EAAI,MAAM,EAAE,EAEtG,IAAMH,EAAQ,CAAC,EACTkB,EAAMf,EAAI,OACZgB,EAAIf,EAAM,EAAI,EACdoB,EAAI,EACJX,EACAI,EACAH,EACAE,EACAS,EACAC,EACJ,KAAOP,EAAID,GAAK,CAEd,OAAa,CAEX,GADAJ,EAAKK,EAAI,EACLL,EAAKI,EAAK,CAEZ,GADAO,GAAQtB,EAAIgB,CAAC,GAAK,GAAKhB,EAAIW,CAAE,EACzBW,EAAO,OAAUA,EAAO,MAAQ,CAClCZ,EAAIY,EACJR,EAAM,EACN,KACF,CAEA,GADAD,EAAKG,EAAI,EACLH,EAAKE,IACPQ,GAAOvB,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIa,CAAE,EAC5BS,GAAQ,OAAUC,GAAO,OAAUA,GAAO,OAAQ,CACpDb,EAAI,OAAYY,EAAO,OAAW,KAAOC,EAAM,OAC/CT,EAAM,EACN,KACF,CAEJ,CAEA,MAAM,IAAI,WAAW,gEAAgEE,CAAC,GAAG,CAC3F,CACAnB,EAAMwB,GAAG,EAAIX,EACbM,GAAKF,CACP,CACA,OAAOjB,CACT,CACF,EAGAX,GAAQ,QAAU,CAChB,OAAOW,EAAO,CACZ,IAAMC,EAAQ,CAAC,EACXF,EACAuB,EACAC,EACJ,QAAS,EAAI,EAAG,EAAIvB,EAAM,OAAQ,GAAK,EAErC,GADAD,EAAOC,EAAM,CAAC,EACTD,GAAQ,GAAKA,GAAQ,OAAYA,GAAQ,OAAUA,GAAQ,MAC9DE,EAAM,KAAKF,EAAOJ,GAAK,CAAC,CAAC,EACzBM,EAAM,KAAMF,GAAQ,EAAKJ,GAAK,CAAC,CAAC,UACvBI,GAAQ,OAAWA,GAAQ,QACpCwB,EAAIxB,EAAO,MACXuB,EAAI,OAAUC,GAAK,IACnBA,EAAI,OAAUA,EAAI5B,GAAK,EAAE,GACzBM,EAAM,KAAKqB,EAAI3B,GAAK,CAAC,CAAC,EACtBM,EAAM,KAAMqB,GAAK,EAAK3B,GAAK,CAAC,CAAC,EAC7BM,EAAM,KAAKsB,EAAI5B,GAAK,CAAC,CAAC,EACtBM,EAAM,KAAMsB,GAAK,EAAK5B,GAAK,CAAC,CAAC,MAE7B,OAAM,IAAI,WAAW,oDAAoD,CAAC,MAAMI,CAAI,EAAE,EAG1F,OAAOT,GAAO,KAAKW,CAAK,CAC1B,EACA,OAAOE,EAAKC,EAAK,CAEf,GAAID,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,mEAAmEA,EAAI,MAAM,EAAE,EAEtG,IAAMH,EAAQ,CAAC,EACTkB,EAAMf,EAAI,OACZgB,EAAIf,EAAM,EAAI,EACdoB,EAAI,EACJX,EACAI,EACAH,EACAE,EACAS,EACAC,EACJ,KAAOP,EAAID,GAAK,CAEd,OAAa,CAEX,GADAJ,EAAKK,EAAI,EACLL,EAAKI,EAAK,CAEZ,GADAO,GAAQtB,EAAIW,CAAE,GAAK,GAAKX,EAAIgB,CAAC,EACzBM,EAAO,OAAUA,EAAO,MAAQ,CAClCZ,EAAIY,EACJR,EAAM,EACN,KACF,CAEA,GADAD,EAAKG,EAAI,EACLH,EAAKE,IACPQ,GAAOvB,EAAIa,CAAE,GAAK,GAAKb,EAAIgB,EAAI,CAAC,EAC5BM,GAAQ,OAAUC,GAAO,OAAUA,GAAO,OAAQ,CACpDb,EAAI,OAAYY,EAAO,OAAW,KAAOC,EAAM,OAC/CT,EAAM,EACN,KACF,CAEJ,CAEA,MAAM,IAAI,WAAW,gEAAgEE,CAAC,GAAG,CAC3F,CACAnB,EAAMwB,GAAG,EAAIX,EACbM,GAAKF,CACP,CACA,OAAOjB,CACT,CACF,EAGAX,GAAQ,QAAU,CAChB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtB,GAAKA,GAAQ,OAAUA,GAAQ,OAAWA,EAAO,QAC/C,MAAM,IAAI,WAAW,6DAA6DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAErGI,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,EAC/BQ,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,CAC1B,CAAC,EACMQ,CACT,EACA,OAAOA,EAAKC,EAAK,CAEf,GAAID,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,2EAA2EA,EAAI,MAAM,EAAE,EAE9G,IAAMH,EAAQ,CAAC,EACXmB,EAAIf,EAAM,EAAI,EAClB,KAAOe,EAAIhB,EAAI,OAAQgB,GAAK,EAAG,CAC7B,IAAMpB,GAAQI,EAAIgB,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIgB,EAAI,CAAC,EAChF,GAAKpB,GAAQ,OAAUA,GAAQ,OAAWA,EAAO,QAC/C,MAAM,IAAI,WAAW,6DAA6DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAErGC,EAAM,KAAKD,CAAI,CACjB,CACA,OAAOC,CACT,CACF,EAGAX,GAAQ,QAAU,CAChB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtB,GAAKA,GAAQ,OAAUA,GAAQ,OAAWA,EAAO,QAC/C,MAAM,IAAI,WAAW,6DAA6DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAErGI,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,EACxBQ,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,EAC/BQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,CAClC,CAAC,EACMQ,CACT,EACA,OAAOA,EAAKC,EAAK,CAEf,GAAID,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,2EAA2EA,EAAI,MAAM,EAAE,EAE9G,IAAMH,EAAQ,CAAC,EACXmB,EAAIf,EAAM,EAAI,EAClB,KAAOe,EAAIhB,EAAI,OAAQgB,GAAK,EAAG,CAC7B,IAAMpB,GAAQI,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIgB,CAAC,EAChF,GAAKpB,GAAQ,OAAUA,GAAQ,OAAWA,EAAO,QAC/C,MAAM,IAAI,WAAW,6DAA6DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAErGC,EAAM,KAAKD,CAAI,CACjB,CACA,OAAOC,CACT,CACF,EAGAX,GAAQ,MAAQ,CACd,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,MAAM,EACrC,QAASmB,EAAI,EAAGA,EAAInB,EAAM,OAAQmB,GAAK,EAAG,CACxC,GAAInB,EAAMmB,CAAC,EAAI,IACb,MAAM,IAAI,WAAW,yDAAyDA,CAAC,MAAMnB,EAAMmB,CAAC,CAAC,EAAE,EAEjGhB,EAAIgB,CAAC,EAAInB,EAAMmB,CAAC,CAClB,CACA,OAAOhB,CACT,EACA,OAAOA,EAAK,CACV,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EAAG,CACtC,GAAIhB,EAAIgB,CAAC,EAAI,IACX,MAAM,IAAI,WAAW,yDAAyDA,CAAC,MAAMhB,EAAIgB,CAAC,CAAC,EAAE,EAE/FnB,EAAMmB,CAAC,EAAIhB,EAAIgB,CAAC,CAClB,CACA,OAAOnB,CACT,CACF,EAGAX,GAAQ,MAAQ,CACd,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,MAAM,EACrC,QAASmB,EAAI,EAAGA,EAAInB,EAAM,OAAQmB,GAAK,EAAG,CACxC,GAAInB,EAAMmB,CAAC,EAAI,IACb,MAAM,IAAI,WAAW,yDAAyDA,CAAC,MAAMnB,EAAMmB,CAAC,CAAC,EAAE,EAEjGhB,EAAIgB,CAAC,EAAInB,EAAMmB,CAAC,CAClB,CACA,OAAOhB,CACT,EACA,OAAOA,EAAK,CACV,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EACnCnB,EAAMmB,CAAC,EAAIhB,EAAIgB,CAAC,EAElB,OAAOnB,CACT,CACF,EAGAX,GAAQ,SAAW,CACjB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtB,GAAIA,EAAO,MACT,MAAM,IAAI,WAAW,+DAA+DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAEvGI,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,EAC/BQ,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,CAC1B,CAAC,EACMQ,CACT,EACA,OAAOA,EAAK,CACV,GAAIA,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,6EAA6EA,EAAI,MAAM,EAAE,EAEhH,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EACnCnB,EAAM,MAAMG,EAAIgB,CAAC,GAAK,GAAKhB,EAAIgB,EAAI,CAAC,CAAC,EAEvC,OAAOnB,CACT,CACF,EAGAX,GAAQ,SAAW,CACjB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtB,GAAIA,EAAO,MACT,MAAM,IAAI,WAAW,+DAA+DoB,EAAI,CAAC,MAAMpB,CAAI,EAAE,EAEvGI,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,EACxBQ,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,CACjC,CAAC,EACMQ,CACT,EACA,OAAOA,EAAK,CACV,GAAIA,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,6EAA6EA,EAAI,MAAM,EAAE,EAEhH,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EACnCnB,EAAM,MAAMG,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIgB,CAAC,CAAC,EAEvC,OAAOnB,CACT,CACF,EAGAX,GAAQ,SAAW,CACjB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtBI,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,EAC/BQ,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,CAC1B,CAAC,EACMQ,CACT,EACA,OAAOA,EAAK,CACV,GAAIA,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,6EAA6EA,EAAI,MAAM,EAAE,EAEhH,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EACnCnB,EAAM,MAAMG,EAAIgB,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIgB,EAAI,CAAC,CAAC,EAEjF,OAAOnB,CACT,CACF,EAGAX,GAAQ,SAAW,CACjB,OAAOW,EAAO,CACZ,IAAMG,EAAMb,GAAO,MAAMU,EAAM,OAAS,CAAC,EACrCmB,EAAI,EACR,OAAAnB,EAAM,QAASD,GAAS,CACtBI,EAAIgB,GAAG,EAAIpB,EAAOJ,GAAK,CAAC,EACxBQ,EAAIgB,GAAG,EAAKpB,GAAQ,EAAKJ,GAAK,CAAC,EAC/BQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,EAChCQ,EAAIgB,GAAG,EAAKpB,GAAQ,GAAMJ,GAAK,CAAC,CAClC,CAAC,EACMQ,CACT,EACA,OAAOA,EAAK,CAEV,GAAIA,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,6EAA6EA,EAAI,MAAM,EAAE,EAEhH,IAAMH,EAAQ,CAAC,EACf,QAASmB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EACnCnB,EAAM,MAAMG,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,KAAOhB,EAAIgB,EAAI,CAAC,GAAK,GAAKhB,EAAIgB,CAAC,CAAC,EAEjF,OAAOnB,CACT,CACF,EAIAX,GAAQ,OAAS,CACf,OAAOW,EAAO,CACZ,OAAOX,GAAQ,QAAQ,OAAOW,CAAK,EAAE,SAAS,SAAS,CACzD,EACA,OAAO2B,EAAK,CACV,OAAOtC,GAAQ,QAAQ,OAAOC,GAAO,KAAKqC,EAAK,SAAS,EAAG,CAAC,CAC9D,CACF,EAKAtC,GAAQ,QAAU,CAEhB,OAAOW,EAAO,CACZ,IAAMC,EAAQ,CAAC,EACf,QAASkB,EAAI,EAAGA,EAAInB,EAAM,OAAQmB,GAAK,EAAG,CACxC,IAAMpB,EAAOC,EAAMmB,CAAC,EACpB,GAAIpB,IAAS,GACXE,EAAM,KAAKF,CAAI,EACfE,EAAM,KAAKF,CAAI,UACNA,IAAS,GAClBE,EAAM,KAAKF,CAAI,UACNA,GAAQ,IAAMA,GAAQ,IAC/BE,EAAM,KAAKF,CAAI,MACV,CACL,IAAI4B,EAAM,GACV,GAAI5B,GAAQ,GAAKA,GAAQ,GACvB4B,GAAO,MAAM/B,GAAMG,CAAI,CAAC,WACfA,GAAQ,KAAOA,GAAQ,IAChC4B,GAAO,MAAM/B,GAAMG,CAAI,CAAC,WACfA,GAAQ,KAASA,GAAQ,MAClC4B,GAAO,MAAM/B,GAAOG,GAAQ,EAAKJ,GAAK,CAAC,CAAC,CAAC,GAAGC,GAAMG,EAAOJ,GAAK,CAAC,CAAC,CAAC,WACxDI,GAAQ,OAAWA,GAAQ,WAAY,CAChD4B,GAAO,MACP,IAAMC,EAAS7B,GAAQ,GAAMJ,GAAK,CAAC,EAC/BiC,EAAQ,IACVD,GAAO/B,GAAMgC,CAAK,GAEpBD,GAAO,GAAG/B,GAAOG,GAAQ,GAAMJ,GAAK,CAAC,CAAC,EAAIC,GAAOG,GAAQ,EAAKJ,GAAK,CAAC,CAAC,EAAIC,GAAMG,EAAOJ,GAAK,CAAC,CAAC,CAAC,GAChG,KACE,OAAM,IAAI,MAAM,oDAAoD,EAE1DL,GAAO,KAAKqC,CAAG,EACvB,QAASE,GAAM,CACjB5B,EAAM,KAAK4B,CAAC,CACd,CAAC,CACH,CACF,CACA,OAAOvC,GAAO,KAAKW,CAAK,CAC1B,EAEA,OAAOE,EAAK,CACV,SAAS2B,EAAMC,EAAK,CAClB,OAAKA,GAAO,IAAMA,GAAO,IAAQA,GAAO,IAAMA,GAAO,IAAQA,GAAO,IAAMA,GAAO,GAInF,CACA,SAASC,EAAKb,EAAGD,EAAKe,EAAQ,CAC5B,IAAMC,EAAM,CAAE,KAAM,KAAM,MAAOf,EAAI,EAAG,MAAO,EAAK,EACpD,GAAIA,EAAI,EAAID,GACNY,EAAMG,EAAOd,CAAC,CAAC,GAAKW,EAAMG,EAAOd,EAAI,CAAC,CAAC,EAAG,CAC5C,IAAMQ,EAAM,OAAO,cAAcM,EAAOd,CAAC,EAAGc,EAAOd,EAAI,CAAC,CAAC,EACzDe,EAAI,KAAO,SAASP,EAAK,EAAE,EACtB,OAAO,MAAMO,EAAI,IAAI,IACxBA,EAAI,MAAQ,GAEhB,CAEF,OAAOA,CACT,CACA,SAASC,EAAKhB,EAAGD,EAAKe,EAAQ,CAC5B,IAAMC,EAAM,CAAE,KAAM,KAAM,MAAOf,EAAI,EAAG,MAAO,EAAK,EACpD,GAAIA,EAAI,EAAID,GACNY,EAAMG,EAAOd,CAAC,CAAC,GAAKW,EAAMG,EAAOd,EAAI,CAAC,CAAC,GAAKW,EAAMG,EAAOd,EAAI,CAAC,CAAC,GAAKW,EAAMG,EAAOd,EAAI,CAAC,CAAC,EAAG,CAC5F,IAAMQ,EAAM,OAAO,cAAcM,EAAOd,CAAC,EAAGc,EAAOd,EAAI,CAAC,EAAGc,EAAOd,EAAI,CAAC,EAAGc,EAAOd,EAAI,CAAC,CAAC,EACvFe,EAAI,KAAO,SAASP,EAAK,EAAE,EACtB,OAAO,MAAMO,EAAI,IAAI,IACxBA,EAAI,MAAQ,GAEhB,CAEF,OAAOA,CACT,CACA,SAASE,EAAKjB,EAAGD,EAAKe,EAAQ,CAC5B,IAAMC,EAAM,CAAE,KAAM,KAAM,MAAOf,EAAI,EAAG,MAAO,EAAK,EAChDQ,EAAM,GACV,KAAOR,EAAID,GAAOY,EAAMG,EAAOd,CAAC,CAAC,GAC/BQ,GAAO,OAAO,cAAcM,EAAOd,CAAC,CAAC,EAErCA,GAAK,EAEP,OAAAe,EAAI,KAAO,SAASP,EAAK,EAAE,EACvBM,EAAOd,CAAC,IAAM,KAAO,CAAC,OAAO,MAAMe,EAAI,IAAI,IAC7CA,EAAI,MAAQ,IAEdA,EAAI,MAAQf,EAAI,EACTe,CACT,CACA,IAAMlC,EAAQ,CAAC,EACTkB,EAAMf,EAAI,OACZW,EACAoB,EACAG,EACAlB,EAAI,EACR,KAAOA,EAAID,GAAK,CAEd,OAAa,CAEX,GADAmB,EAAQ,GACJlC,EAAIgB,CAAC,IAAM,GAAI,CAEjBnB,EAAM,KAAKG,EAAIgB,CAAC,CAAC,EACjBA,GAAK,EACLkB,EAAQ,GACR,KACF,CAEA,GADAvB,EAAKK,EAAI,EACLL,GAAMI,EACR,MAEF,GAAIf,EAAIW,CAAE,IAAM,GAAI,CAElBd,EAAM,KAAK,EAAE,EACbmB,GAAK,EACLkB,EAAQ,GACR,KACF,CACA,GAAIlC,EAAIW,CAAE,IAAM,IAAK,CAEnB,GADAoB,EAAMF,EAAKlB,EAAK,EAAGI,EAAKf,CAAG,EACvB+B,EAAI,MACN,MAGFlC,EAAM,KAAKkC,EAAI,IAAI,EACnBf,EAAIe,EAAI,MACRG,EAAQ,GACR,KACF,CACA,GAAIlC,EAAIW,CAAE,IAAM,IAAK,CACnB,GAAIX,EAAIW,EAAK,CAAC,IAAM,IAAK,CAEvB,GADAoB,EAAME,EAAKtB,EAAK,EAAGI,EAAKf,CAAG,EACvB+B,EAAI,MACN,MAGFlC,EAAM,KAAKkC,EAAI,IAAI,EACnBf,EAAIe,EAAI,MACRG,EAAQ,GACR,KACF,CAEA,GADAH,EAAMC,EAAKrB,EAAK,EAAGI,EAAKf,CAAG,EACvB+B,EAAI,MACN,MAGFlC,EAAM,KAAKkC,EAAI,IAAI,EACnBf,EAAIe,EAAI,MACRG,EAAQ,GACR,KACF,CACA,KACF,CACA,GAAIA,EACF,MAAM,IAAI,MAAM,qDAAqDlB,CAAC,GAAG,CAE7E,CACA,OAAOnB,CACT,CACF,EAGA,IAAMsC,GAAK,GACLC,GAAK,GACXlD,GAAQ,SAAW,CACjB,KAAKW,EAAO,CACV,IAAMwC,EAAU,CAAC,EACbrB,EAAI,EACR,KAAOA,EAAInB,EAAM,QACf,OAAQA,EAAMmB,CAAC,EAAG,CAChB,KAAKmB,GACCnB,EAAI,EAAInB,EAAM,QAAUA,EAAMmB,EAAI,CAAC,IAAMoB,GAC3CpB,GAAK,EAELA,GAAK,EAEPqB,EAAQ,KAAKF,EAAE,EACfE,EAAQ,KAAKD,EAAE,EACf,MACF,KAAKA,GACHC,EAAQ,KAAKF,EAAE,EACfE,EAAQ,KAAKD,EAAE,EACfpB,GAAK,EACL,MACF,QACEqB,EAAQ,KAAKxC,EAAMmB,CAAC,CAAC,EACrBA,GAAK,EACL,KACJ,CAEF,OAAIqB,EAAQ,OAAS,GAAKA,EAAQA,EAAQ,OAAS,CAAC,IAAMD,KACxDC,EAAQ,KAAKF,EAAE,EACfE,EAAQ,KAAKD,EAAE,GAEVC,CACT,EACA,GAAGxC,EAAO,CACR,IAAMwC,EAAU,CAAC,EACbrB,EAAI,EACR,KAAOA,EAAInB,EAAM,QACf,OAAQA,EAAMmB,CAAC,EAAG,CAChB,KAAKmB,GACCnB,EAAI,EAAInB,EAAM,QAAUA,EAAMmB,EAAI,CAAC,IAAMoB,GAC3CpB,GAAK,EAELA,GAAK,EAEPqB,EAAQ,KAAKD,EAAE,EACf,MACF,KAAKA,GACHC,EAAQ,KAAKD,EAAE,EACfpB,GAAK,EACL,MACF,QACEqB,EAAQ,KAAKxC,EAAMmB,CAAC,CAAC,EACrBA,GAAK,EACL,KACJ,CAEF,OAAIqB,EAAQ,OAAS,GAAKA,EAAQA,EAAQ,OAAS,CAAC,IAAMD,IACxDC,EAAQ,KAAKD,EAAE,EAEVC,CACT,CACF,EAGAnD,GAAQ,OAAS,CACf,OAAOc,EAAK,CACV,GAAIA,EAAI,SAAW,EACjB,OAAOb,GAAO,MAAM,CAAC,EAEvB,IAAI6B,EACAK,EACA,EACAiB,EAAOtC,EAAI,OAAS,EACxBsC,EAAOA,EAAO,EAAI,EAAIA,EAAO,EAC7B,IAAIC,GAASvC,EAAI,OAASsC,GAAQ,EAC5BE,EAASrD,GAAO,MAAMoD,EAAQ,CAAC,EACjCD,EAAO,IACTC,GAAS,GAEXvB,EAAI,EACJK,EAAI,EACJ,QAAStB,EAAI,EAAGA,EAAIwC,EAAOxC,GAAK,EAC9B,EAAIC,EAAIgB,GAAG,GAAK,GAChB,GAAKhB,EAAIgB,GAAG,GAAK,EACjB,GAAKhB,EAAIgB,GAAG,EACZwB,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,EAAKH,GAAK,CAAC,CAAC,EAC5CgD,EAAOnB,GAAG,EAAI1B,GAAY,EAAIH,GAAK,CAAC,CAAC,EAEvC,GAAI8C,IAAS,EACX,OAAOE,EAET,GAAIF,IAAS,EACX,SAAItC,EAAIgB,GAAG,GAAK,GAChB,GAAKhB,EAAIgB,CAAC,GAAK,EACfwB,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,EAAKH,GAAK,CAAC,CAAC,EAC5CgD,EAAOnB,CAAC,EAAI1B,GAAY,EAAE,EACnB6C,EAET,GAAIF,IAAS,EACX,SAAItC,EAAIgB,CAAC,GAAK,GACdwB,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAa,GAAK,GAAMH,GAAK,CAAC,CAAC,EAC7CgD,EAAOnB,GAAG,EAAI1B,GAAY,EAAE,EAC5B6C,EAAOnB,CAAC,EAAI1B,GAAY,EAAE,EACnB6C,CAGX,EACA,OAAOC,EAAO,CAEZ,SAASC,EAAS1C,EAAK,CACrB,IAAMH,EAAQ,CAAC,EACXyC,EAAO,EACX,QAAStB,EAAI,EAAGA,EAAIhB,EAAI,OAAQgB,GAAK,EAAG,CACtC,IAAMpB,EAAOI,EAAIgB,CAAC,EACZC,EAAO,GACb,KAAOA,GACD,EAAArB,IAAS,IAAMA,IAAS,GAAKA,IAAS,IAAMA,IAAS,KAD9C,CAIX,GAAIA,GAAQ,IAAMA,GAAQ,GAAI,CAC5BC,EAAM,KAAKD,EAAO,EAAE,EACpB,KACF,CACA,GAAIA,GAAQ,IAAMA,GAAQ,IAAK,CAC7BC,EAAM,KAAKD,EAAO,EAAE,EACpB,KACF,CACA,GAAIA,GAAQ,IAAMA,GAAQ,GAAI,CAC5BC,EAAM,KAAKD,EAAO,CAAC,EACnB,KACF,CACA,GAAIA,IAAS,GAAI,CACfC,EAAM,KAAK,EAAE,EACb,KACF,CACA,GAAID,IAAS,GAAI,CACfC,EAAM,KAAK,EAAE,EACb,KACF,CACA,GAAID,IAAS,GAAI,CACfC,EAAM,KAAK,EAAE,EACbyC,GAAQ,EACR,KACF,CAEA,MAAM,IAAI,WAAW,wCAAwCtB,CAAC,MAAMpB,CAAI,EAAE,CAC5E,CACF,CAEA,GAAIC,EAAM,OAAS,EAAI,EACrB,MAAM,IAAI,WAAW,4DAA4DA,EAAM,MAAM,EAAE,EAGjG,OAAQyC,EAAM,CACZ,IAAK,GACH,MACF,IAAK,GACH,GAAIzC,EAAMA,EAAM,OAAS,CAAC,IAAM,GAC9B,MAAM,IAAI,WAAW,6DAA6D,EAEpF,MACF,IAAK,GACH,GAAIA,EAAMA,EAAM,OAAS,CAAC,IAAM,IAAMA,EAAMA,EAAM,OAAS,CAAC,IAAM,GAChE,MAAM,IAAI,WAAW,+DAA+D,EAEtF,MACF,QACE,MAAM,IAAI,WAAW,uDAAuDyC,CAAI,EAAE,CACtF,CACA,MAAO,CAAE,KAAAA,EAAM,IAAKnD,GAAO,KAAKU,CAAK,CAAE,CACzC,CAEA,GAAI4C,EAAM,SAAW,EACnB,OAAOtD,GAAO,MAAM,CAAC,EAEvB,IAAMwD,EAAMD,EAASD,CAAK,EACpB,CAAE,KAAAH,CAAK,EAAIK,EACXH,EAASG,EAAI,IACf,EACAtB,EACAuB,EACAL,EAAQC,EAAO,OAAS,EACtBxC,EAAMb,GAAO,MAAMoD,EAAQ,EAAID,CAAI,EACrCA,EAAO,IACTC,GAAS,GAEXlB,EAAI,EACJ,EAAI,EACJ,QAAStB,EAAI,EAAGA,EAAIwC,EAAOxC,GAAK,EAC9B6C,EAAIJ,EAAO,GAAG,GAAK,GACnBI,GAAKJ,EAAO,GAAG,GAAK,GACpBI,GAAKJ,EAAO,GAAG,GAAK,EACpBI,GAAKJ,EAAO,GAAG,EACfxC,EAAIqB,GAAG,EAAKuB,GAAK,GAAMpD,GAAK,CAAC,EAC7BQ,EAAIqB,GAAG,EAAKuB,GAAK,EAAKpD,GAAK,CAAC,EAC5BQ,EAAIqB,GAAG,EAAIuB,EAAIpD,GAAK,CAAC,EAEvB,OAAI8C,IAAS,IACXM,EAAIJ,EAAO,GAAG,GAAK,GACnBI,GAAKJ,EAAO,GAAG,GAAK,GACpBI,GAAKJ,EAAO,CAAC,GAAK,EAClBxC,EAAIqB,GAAG,EAAKuB,GAAK,GAAMpD,GAAK,CAAC,EAC7BQ,EAAIqB,CAAC,EAAKuB,GAAK,EAAKpD,GAAK,CAAC,GAExB8C,IAAS,IACXM,EAAIJ,EAAO,GAAG,GAAK,GACnBI,GAAKJ,EAAO,GAAG,GAAK,GACpBxC,EAAIqB,CAAC,EAAKuB,GAAK,GAAMpD,GAAK,CAAC,GAEtBQ,CACT,EAEA,SAASA,EAAK,CACZ,GAAIA,EAAI,OAAS,EAAI,EACnB,MAAM,IAAI,WAAW,2DAA2DA,EAAI,MAAM,EAAE,EAE9F,IAAIwB,EAAM,GACNqB,EAAU,EACd,SAASC,EAAUC,EAAIC,EAAIC,EAAIC,EAAI,CACjC,OAAQL,EAAS,CACf,IAAK,IACHrB,GAAO;AAAA,EAAOuB,CAAE,GAAGC,CAAE,GAAGC,CAAE,GAAGC,CAAE,GAC/BL,EAAU,EACV,MACF,IAAK,IACHrB,GAAO,GAAGuB,CAAE;AAAA,EAAOC,CAAE,GAAGC,CAAE,GAAGC,CAAE,GAC/BL,EAAU,EACV,MACF,IAAK,IACHrB,GAAO,GAAGuB,EAAKC,CAAE;AAAA,EAAOC,CAAE,GAAGC,CAAE,GAC/BL,EAAU,EACV,MACF,IAAK,IACHrB,GAAO,GAAGuB,EAAKC,EAAKC,CAAE;AAAA,EAAOC,CAAE,GAC/BL,EAAU,EACV,MACF,QACErB,GAAOuB,EAAKC,EAAKC,EAAKC,EACtBL,GAAW,EACX,KACJ,CACF,CACA,SAASH,EAAShC,EAAG,CAgBnB,OAfIA,GAAK,IAAMA,GAAK,IAGhBA,GAAK,IAAMA,GAAK,KAGhBA,GAAK,IAAMA,GAAK,IAGhBA,IAAM,IAGNA,IAAM,IAGNA,IAAM,EAIZ,CACA,QAAS,EAAI,EAAG,EAAIV,EAAI,OAAQ,GAAK,EAAG,CACtC,QAASqB,EAAI,EAAGA,EAAI,EAAI,EAAGA,GAAK,EAC9B,GAAI,CAACqB,EAAS1C,EAAIqB,CAAC,CAAC,EAClB,MAAM,IAAI,WAAW,wBAAwBA,CAAC,MAAMrB,EAAIqB,CAAC,CAAC,oCAAoC,EAGlGyB,EACE,OAAO,aAAa9C,EAAI,CAAC,CAAC,EAC1B,OAAO,aAAaA,EAAI,EAAI,CAAC,CAAC,EAC9B,OAAO,aAAaA,EAAI,EAAI,CAAC,CAAC,EAC9B,OAAO,aAAaA,EAAI,EAAI,CAAC,CAAC,CAChC,CACF,CACA,OAAOwB,CACT,CACF,ICnuCA,IAAA2B,GAAAC,GAAAC,IAAA,eAaA,GAAM,CAAE,OAAAC,EAAO,EAAI,KAEbC,GAAQ,KAGRC,GAAO,OACPC,GAAQ,QACRC,GAAU,UACVC,GAAU,UACVC,GAAQ,QACRC,GAAU,UACVC,GAAU,UACVC,GAAQ,QACRC,GAAQ,QACRC,GAAS,SACTC,GAAQ,QACRC,GAAS,SACTC,GAAW,WACXC,GAAW,WACXC,GAAS,SACTC,GAAW,WACXC,GAAW,WACXC,GAAU,UACVC,GAAS,SAITC,GAAO,SAAcC,EAAK,CAC9BA,EAAI,KAAOpB,GACX,IAAMqB,EAAMD,EAAI,KAChBA,EAAI,IAAM,EACNC,EAAI,QAAU,GACZA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,MACnDD,EAAI,IAAM,EAGhB,EAIME,GAAQ,SAAeF,EAAK,CAChC,IAAMC,EAAMD,EAAI,KAEhB,OADAA,EAAI,IAAM,EACFA,EAAI,KAAM,CAChB,KAAKnB,GACHmB,EAAI,KAAOlB,GACPmB,EAAI,QAAU,IACZA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,IAChCD,EAAI,IAAM,EACDC,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,MACvCD,EAAI,KAAOjB,GACXiB,EAAI,IAAM,IAGd,MACF,KAAKlB,GAEH,GADAkB,EAAI,KAAOlB,GACPmB,EAAI,QAAU,GAChB,GAAIA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,IAChCD,EAAI,IAAM,UACDC,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,IACvC,MAAM,IAAI,UAAU,cAAcnB,EAAO,+BAA+BC,EAAO,GAAG,EAGtF,MACF,KAAKA,GAEH,GADAiB,EAAI,KAAOjB,GACPkB,EAAI,QAAU,EAAG,CACnB,GAAIA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,IAChC,MAAM,IAAI,UAAU,cAAclB,EAAO,+BAA+BD,EAAO,GAAG,EACzEmB,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,MACvCD,EAAI,IAAM,EAEd,CACA,MACF,QACE,MAAM,IAAI,UAAU,wBAAwBA,EAAI,IAAI,gBAAgB,CACxE,CACF,EAIMG,GAAQ,SAAeH,EAAK,CAChC,IAAMC,EAAMD,EAAI,KAEhB,OADAA,EAAI,IAAM,EACFA,EAAI,KAAM,CAChB,KAAKhB,GACHgB,EAAI,KAAOf,GACPgB,EAAI,QAAU,IACZA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,MAChED,EAAI,IAAM,GAERC,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,IACnED,EAAI,KAAOd,GACXc,EAAI,IAAM,IAGd,MACF,KAAKf,GAEH,GADAe,EAAI,KAAOf,GACPgB,EAAI,QAAU,IACZA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,MAChED,EAAI,IAAM,GAERC,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,GACnE,MAAM,IAAI,UAAU,aAAahB,EAAO,6BAA6BC,EAAO,GAAG,EAGnF,MACF,KAAKA,GAEH,GADAc,EAAI,KAAOd,GACPe,EAAI,QAAU,EAAG,CACnB,GAAIA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,IAChE,MAAM,IAAI,UAAU,cAAcf,EAAO,+BAA+BD,EAAO,GAAG,EAEhFgB,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,KAAQA,EAAI,CAAC,IAAM,GAAKA,EAAI,CAAC,IAAM,IACnED,EAAI,IAAM,EAEd,CACA,MACF,QACE,MAAM,IAAI,UAAU,wBAAwBA,EAAI,IAAI,gBAAgB,CACxE,CACF,EAOMI,GAAc,SAAqBC,EAAMC,EAAM,CACnD,SAASC,EAAQC,EAAS,CACxB,IAAMC,EAAM,CACV,KAAM,GACN,OAAQ,EACV,EAEMC,EADK,8BACO,KAAKF,CAAO,EAC9B,OAAIE,IACEA,EAAO,CAAC,IACVD,EAAI,KAAOC,EAAO,CAAC,EAAE,YAAY,GAE/BA,EAAO,CAAC,IACVD,EAAI,OAAS,KAGVA,CACT,CACA,IAAMA,EAAMF,EAAQF,EAAK,YAAY,CAAC,EACtC,GAAII,EAAI,OAAQ,CAEd,GAAIA,EAAI,OAASX,GACf,MAAM,IAAI,UAAU,UAAUO,CAAI,2CAA2CP,EAAM,EAAE,EAEvF,GAAIpB,GAAO,SAAS4B,CAAI,EACtBG,EAAI,KAAO9B,GAAM,OAAO,OAAO2B,CAAI,UAC1B,OAAOA,GAAS,SAAU,CACnC,IAAML,EAAMvB,GAAO,KAAK4B,EAAM,OAAO,EACrCG,EAAI,KAAO9B,GAAM,OAAO,OAAOsB,CAAG,CACpC,KACE,OAAM,IAAI,UAAU,UAAUI,CAAI,0CAA0C,OAAOC,CAAI,EAAE,CAE7F,MACEG,EAAI,KAAOH,EAEb,OAAQG,EAAI,KAAM,CAChB,KAAK7B,GACHmB,GAAKU,CAAG,EACR,MACF,KAAK5B,GACL,KAAKC,GACL,KAAKC,GACHmB,GAAMO,CAAG,EACT,MACF,KAAKzB,GACL,KAAKC,GACL,KAAKC,GACHiB,GAAMM,CAAG,EACT,MACF,KAAKlB,GACHkB,EAAI,KAAOhB,GACX,MACF,KAAKC,GACHe,EAAI,KAAOb,GACX,MACF,KAAKR,GACHqB,EAAI,KAAOtB,GACX,MACF,KAAKE,GACHoB,EAAI,KAAOnB,GACX,MACF,KAAKH,GACL,KAAKG,GACL,KAAKE,GACL,KAAKC,GACL,KAAKE,GACL,KAAKC,GACL,KAAKE,GACL,KAAKD,GACH,MACF,QACE,MAAM,IAAI,UAAU,UAAUQ,CAAI,kBAAkB,CACxD,CACA,GAAII,EAAI,OAASX,IACf,GAAI,OAAOW,EAAI,MAAS,SACtB,MAAM,IAAI,UAAU,UAAUJ,CAAI,4BAA4B,UAEvD,CAAC3B,GAAO,SAAS+B,EAAI,IAAI,EAClC,MAAM,IAAI,UAAU,UAAUJ,CAAI,4BAA4B,EAEhE,OAAOI,CACT,EAIME,GAAc,SAAqBN,EAAMO,EAAO,CACpD,SAASL,EAAQC,EAAS,CACxB,IAAIK,EACAC,EACEL,EAAM,CACV,KAAM,GACN,GAAI,GACJ,OAAQ,GACR,KAAM,EACR,EAEMM,EAAO,GACb,KAAOA,GAAM,CAGX,GAFAD,EAAMN,EACNK,EAAML,EAAQ,MAAM,EAAG,CAAC,EACpBK,IAAQ,QAAS,CACnBJ,EAAI,KAAO,GACXK,EAAMN,EAAQ,MAAM,CAAC,EACrB,KACF,CAEA,GADAK,EAAML,EAAQ,MAAM,EAAG,CAAC,EACpBK,IAAQ,MAAO,CACjBJ,EAAI,GAAK,GACTK,EAAMN,EAAQ,MAAM,CAAC,EACrB,KACF,CACA,KACF,CAEA,OAAAK,EAAMC,EAAI,MAAM,GAAG,EACfD,EAAI,SAAW,EAEjBJ,EAAI,KAAOI,EAAI,CAAC,EACPA,EAAI,SAAW,GAAKA,EAAI,CAAC,IAAM,WACxCJ,EAAI,OAAS,GAEbA,EAAI,KAAOI,EAAI,CAAC,GAEXJ,CACT,CACA,GAAI,CAAC,MAAM,QAAQG,CAAK,EACtB,MAAM,IAAI,UAAU,0BAA0B,OAAOA,CAAK,EAAE,EAE9D,GAAI,OAAOP,GAAS,SAClB,MAAM,IAAI,UAAU,0BAA0B,OAAOA,CAAI,EAAE,EAE7D,IAAMI,EAAMF,EAAQF,EAAK,YAAY,CAAC,EACtC,OAAQI,EAAI,KAAM,CAChB,KAAK7B,GACL,KAAKE,GACL,KAAKC,GACL,KAAKE,GACL,KAAKC,GACL,KAAKC,GACL,KAAKG,GACL,KAAKE,GACL,KAAKC,GACL,KAAKE,GACL,KAAKC,GACL,KAAKC,GACH,MACF,KAAKC,GACH,GAAIW,EAAI,OACN,MAAM,IAAI,UAAU,0CAA0CX,EAAM,EAAE,EAExE,MACF,KAAKV,GACHqB,EAAI,KAAOtB,GACX,MACF,KAAKE,GACHoB,EAAI,KAAOnB,GACX,MACF,KAAKT,GACH4B,EAAI,KAAO3B,GACX,MACF,KAAKE,GACHyB,EAAI,KAAOxB,GACX,MACF,KAAKM,GACHkB,EAAI,KAAOhB,GACX,MACF,KAAKC,GACHe,EAAI,KAAOb,GACX,MACF,QACE,MAAM,IAAI,UAAU,2BAA2BS,CAAI,6CAA6C,CACpG,CACA,OAAOI,CACT,EAEMO,GAAS,SAAgBX,EAAMO,EAAO,CAC1C,OAAQP,EAAM,CACZ,KAAKzB,GACH,OAAOD,GAAM,KAAK,OAAOiC,CAAK,EAChC,KAAK9B,GACH,OAAOH,GAAM,QAAQ,OAAOiC,CAAK,EACnC,KAAK7B,GACH,OAAOJ,GAAM,QAAQ,OAAOiC,CAAK,EACnC,KAAK3B,GACH,OAAON,GAAM,QAAQ,OAAOiC,CAAK,EACnC,KAAK1B,GACH,OAAOP,GAAM,QAAQ,OAAOiC,CAAK,EACnC,KAAKzB,GACH,OAAOR,GAAM,MAAM,OAAOiC,CAAK,EACjC,KAAKtB,GACH,OAAOX,GAAM,MAAM,OAAOiC,CAAK,EACjC,KAAKnB,GACH,OAAOd,GAAM,SAAS,OAAOiC,CAAK,EACpC,KAAKpB,GACH,OAAOb,GAAM,SAAS,OAAOiC,CAAK,EACpC,KAAKhB,GACH,OAAOjB,GAAM,SAAS,OAAOiC,CAAK,EACpC,KAAKjB,GACH,OAAOhB,GAAM,SAAS,OAAOiC,CAAK,EACpC,KAAKd,GACH,OAAOnB,GAAM,OAAO,OAAOiC,CAAK,EAClC,KAAKf,GACH,OAAOlB,GAAM,QAAQ,OAAOiC,CAAK,EACnC,QACE,MAAM,IAAI,UAAU,gBAAgBP,CAAI,kBAAkB,CAC9D,CACF,EAGMY,GAAS,SAAgBjB,EAAK,CAClC,OAAQA,EAAI,KAAM,CAChB,KAAKpB,GACH,OAAOD,GAAM,KAAK,OAAOqB,EAAI,KAAMA,EAAI,GAAG,EAC5C,KAAKjB,GACH,OAAOJ,GAAM,QAAQ,OAAOqB,EAAI,KAAMA,EAAI,GAAG,EAC/C,KAAKlB,GACH,OAAOH,GAAM,QAAQ,OAAOqB,EAAI,KAAMA,EAAI,GAAG,EAC/C,KAAKf,GACH,OAAON,GAAM,QAAQ,OAAOqB,EAAI,KAAMA,EAAI,GAAG,EAC/C,KAAKd,GACH,OAAOP,GAAM,QAAQ,OAAOqB,EAAI,KAAMA,EAAI,GAAG,EAC/C,KAAKb,GACH,OAAOR,GAAM,MAAM,OAAOqB,EAAI,IAAI,EACpC,KAAKV,GACH,OAAOX,GAAM,MAAM,OAAOqB,EAAI,IAAI,EACpC,KAAKP,GACH,OAAOd,GAAM,SAAS,OAAOqB,EAAI,IAAI,EACvC,KAAKR,GACH,OAAOb,GAAM,SAAS,OAAOqB,EAAI,IAAI,EACvC,KAAKJ,GACH,OAAOjB,GAAM,SAAS,OAAOqB,EAAI,IAAI,EACvC,KAAKL,GACH,OAAOhB,GAAM,SAAS,OAAOqB,EAAI,IAAI,EACvC,KAAKF,GACH,OAAOnB,GAAM,OAAO,OAAOqB,EAAI,IAAI,EACrC,KAAKH,GACH,OAAOlB,GAAM,QAAQ,OAAOqB,EAAI,IAAI,EACtC,QACE,MAAM,IAAI,UAAU,gBAAgBA,EAAI,IAAI,kBAAkB,CAClE,CACF,EAGAvB,GAAQ,OAAS,SAAuB4B,EAAMC,EAAM,CAClD,IAAMN,EAAMI,GAAYC,EAAMC,CAAI,EAClC,OAAOW,GAAOjB,CAAG,CACnB,EAEAvB,GAAQ,OAAS,SAAuB4B,EAAMO,EAAO,CACnD,IAAIM,EACAjB,EACEkB,EAAMR,GAAYN,EAAMO,CAAK,EACnC,OAAIO,EAAI,MAEND,EAAIvC,GAAM,SAAS,KAAKiC,CAAK,EAC7BX,EAAMe,GAAOG,EAAI,KAAMD,CAAC,GACfC,EAAI,IAEbD,EAAIvC,GAAM,SAAS,GAAGiC,CAAK,EAC3BX,EAAMe,GAAOG,EAAI,KAAMD,CAAC,GAExBjB,EAAMe,GAAOG,EAAI,KAAMP,CAAK,EAE1BO,EAAI,SAENlB,EAAMtB,GAAM,OAAO,OAAOsB,CAAG,GAExBA,CACT,EAGA,IAAMmB,GAAU,SAAiBC,EAASC,EAASC,EAAS,CAC1D,OAAO9C,GAAQ,OAAO8C,EAAS9C,GAAQ,OAAO4C,EAASC,CAAO,CAAC,CACjE,EACA7C,GAAQ,QAAU2C,KCjalB,IAAAI,GAAAC,GAAA,CAAAC,GAAAC,KAAA,CAGAA,GAAO,QAAU,UAAmB,CACpC,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CACP,ICLA,IAAAC,GAAAC,GAAAC,IAAA,CASA,IAAMC,GAAQ,KACRC,GAAY,KACZC,GAAU,KACVC,GAAK,KAELC,GAAe,iBAIfC,GAAY,SAAUC,EAAQC,EAAQC,EAAK,CAC/C,IAAIC,EACAC,EAAMH,EACJI,EAAO,GACb,KAAOA,GAAM,CACX,GAAIL,GAAU,EAAG,CACfI,EAAM,EACND,EAAM,EACN,KACF,CACA,GAAI,OAAOC,GAAQ,SAAU,CAC3BA,EAAM,EACND,EAAMH,EACN,KACF,CACA,GAAII,GAAOJ,EAAQ,CACjBI,EAAMJ,EACNG,EAAMH,EACN,KACF,CACA,GAAI,OAAOE,GAAQ,SAAU,CAC3BC,EAAMH,EACN,KACF,CAEA,GADAG,EAAMC,EAAMF,EACRC,EAAMH,EAAQ,CAChBG,EAAMH,EACN,KACF,CACA,KACF,CACA,MAAO,CACL,IAAAI,EACA,IAAAD,CACF,CACF,EAIAV,GAAQ,WAAa,SAAUa,EAAMC,EAAU,CAC7C,IAAIC,EACJ,GAAI,OAAOF,GAAS,SAClB,MAAM,IAAI,MAAM,GAAGR,EAAY,wCAAwC,EAErE,OAAOS,GAAa,SACtBC,EAAQ,aAERA,EAAQD,EAEV,IAAIE,EAAO,GACX,OAAAA,GAAQ;AAAA,EACRA,GAAQ;AAAA,EACRA,GAAQ;AAAA,EACRA,GAAQ;AAAA,EACRA,GAAQ,UAAUD,CAAK;AAAA,EACvBC,GAAQ;AAAA,EACRA,GAAQb,GAAQ,EAChBa,GAAQ;AAAA,EACRA,GAAQ;AAAA;AAAA,EACRA,GAAQ,MAAM,IAAI,IAAM;AAAA,EACxBA,GAAQH,EACRG,GAAQ;AAAA;AAAA,EACDA,CACT,EAkBAhB,GAAQ,mBAAqB,SAAUiB,EAAQC,EAAS,CACtD,IAAIC,EAAM,KACN,OAAOD,GAAY,UAAYA,IAAY,KAC7CC,EAAMD,GAER,IAAIE,EACAC,EACAJ,EAAO,UAAY,GACrBG,EAAU,gBAAgBnB,GAAM,WAAW,gBAE3CmB,EAAU,gBAAgBnB,GAAM,aAAa,iBAE3CgB,EAAO,QAAUb,GAAG,MACtBiB,EAAQ,gBAAgBpB,GAAM,WAAW,iBAChCgB,EAAO,QAAUb,GAAG,MAC7BiB,EAAQ,gBAAgBpB,GAAM,WAAW,iBAChCgB,EAAO,QAAUb,GAAG,QAC7BiB,EAAQ,gBAAgBpB,GAAM,aAAa,mBAE3CoB,EAAQ,gBAAgBpB,GAAM,aAAa,wBAE7C,IAAIY,EAAO,GACX,OAAAA,GAAQ,iBAAiBZ,GAAM,WAAW;AAAA,EACtCkB,IACFN,GAAQ,YAAYM,CAAG;AAAA,GAEzBN,GAAQ;AAAA,EACRA,GAAQ,kCAAkCO,CAAO;AAAA,EACjDP,GAAQ,oBAAoBZ,GAAM,WAAW;AAAA,EAC7CY,GAAQ,iBAAiBZ,GAAM,aAAa,2BAC5CY,GAAQ;AAAA,EACRA,GAAQ,gCAAgCQ,CAAK;AAAA,EAC7CR,GAAQ,oBAAoBZ,GAAM,WAAW,mBAC7CY,GAAQ,gBAAgBZ,GAAM,WAAW;AAAA,EACzCY,GAAQ,gBAAgBZ,GAAM,aAAa;AAAA,EAC3CY,GAAQ,iCAAiCI,EAAO,MAAM;AAAA,EACtDJ,GAAQ,kCAAkCI,EAAO,OAAO;AAAA,EACxDJ,GAAQ,+BAA+BI,EAAO,UAAU;AAAA,EACxDJ,GAAQ,kCAAkCI,EAAO,YAAY;AAAA,EAC7DJ,GAAQ,6BAA6BI,EAAO,QAAQ;AAAA,EACpDJ,GAAQ,gCAAgCI,EAAO,WAAW;AAAA,EAC1DJ,GAAQ,oCAAoCI,EAAO,QAAQ;AAAA,EAC3DJ,GAAQ,kCAAkCI,EAAO,MAAM;AAAA,EACvDJ,GAAQ,qCAAqCI,EAAO,SAAS;AAAA,EAC7DJ,GAAQ;AAAA,EACDA,CACT,EAGAb,GAAQ,cAAgB,SAAUsB,EAAOC,EAAaC,EAAc,CAClE,IAAIb,EACAD,EACJ,GAAI,OAAOa,GAAgB,SAAU,CACnC,GAAIA,GAAeD,EAAM,OACvB,MAAO,GAETX,EAAMY,EAAc,EAAI,EAAIA,CAC9B,MACEZ,EAAM,EAER,GAAI,OAAOa,GAAiB,SAAU,CACpC,GAAIA,GAAgB,EAClB,MAAO,GAETd,EAAMc,EAAeF,EAAM,OAASX,EAAMW,EAAM,OAASX,EAAMa,CACjE,MACEd,EAAMY,EAAM,OAEd,OAAIX,EAAMD,EACDR,GAAU,OAAO,UAAWoB,EAAM,MAAMX,EAAKD,CAAG,CAAC,EAAE,SAAS,SAAS,EAEvE,EACT,EAEAV,GAAQ,cAAgB,SAAUyB,EAAQ,CACxC,OAAOvB,GAAU,OAAO,SAAUuB,CAAM,CAC1C,EAEAzB,GAAQ,eAAiB,SAAU0B,EAAM,CACvC,IAAIC,EAAM,UACV,OAAQD,EAAM,CACZ,KAAKtB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,KAAKvB,GAAG,IACNuB,EAAM,MACN,MACF,QACE,MAAM,IAAI,MAAM,qBAAqB,CACzC,CACA,OAAOA,CACT,EAEA3B,GAAQ,cAAgB,SAAUqB,EAAO,CACvC,IAAIM,EAAM,UACV,OAAQN,EAAO,CACb,KAAKjB,GAAG,OACNuB,EAAM,SACN,MACF,KAAKvB,GAAG,MACNuB,EAAM,QACN,MACF,KAAKvB,GAAG,MACNuB,EAAM,QACN,MACF,KAAKvB,GAAG,QACNuB,EAAM,UACN,MACF,QACE,MAAM,IAAI,MAAM,oBAAoB,CACxC,CACA,OAAOA,CACT,EAEA3B,GAAQ,WAAa,CACnB,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,KACA,KACA,KACA,KACA,SACA,IACA,QACA,IACA,IACA,IACA,QACA,QACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QACA,IACA,QACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACF,EAEAA,GAAQ,UAAY,SAAU4B,EAAM,CAClC,IAAIC,EAAK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;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO;AAAA,EACPA,GAAO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",
  "names": ["require_base64_js", "__commonJSMin", "exports", "byteLength", "toByteArray", "fromByteArray", "lookup", "revLookup", "Arr", "code", "i", "len", "getLens", "b64", "validLen", "placeHoldersLen", "lens", "_byteLength", "tmp", "arr", "curByte", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "extraBytes", "parts", "maxChunkLength", "len2", "require_ieee754", "__commonJSMin", "exports", "buffer", "offset", "isLE", "mLen", "nBytes", "e", "m", "eLen", "eMax", "eBias", "nBits", "i", "d", "s", "value", "rt", "require_buffer", "__commonJSMin", "exports", "base64", "ieee754", "customInspectSymbol", "Buffer", "SlowBuffer", "K_MAX_LENGTH", "typedArraySupport", "arr", "proto", "e", "createBuffer", "length", "buf", "arg", "encodingOrOffset", "allocUnsafe", "from", "value", "fromString", "fromArrayView", "isInstance", "fromArrayBuffer", "valueOf", "b", "fromObject", "assertSize", "size", "alloc", "fill", "encoding", "checked", "string", "byteLength", "actual", "fromArrayLike", "array", "i", "arrayView", "copy", "byteOffset", "obj", "len", "numberIsNaN", "a", "x", "y", "list", "buffer", "pos", "mustMatch", "loweredCase", "utf8ToBytes", "base64ToBytes", "slowToString", "start", "end", "hexSlice", "utf8Slice", "asciiSlice", "latin1Slice", "base64Slice", "utf16leSlice", "swap", "n", "m", "str", "max", "target", "thisStart", "thisEnd", "thisCopy", "targetCopy", "bidirectionalIndexOf", "val", "dir", "arrayIndexOf", "indexSize", "arrLength", "valLength", "read", "foundIndex", "found", "j", "hexWrite", "offset", "remaining", "strLen", "parsed", "utf8Write", "blitBuffer", "asciiWrite", "asciiToBytes", "base64Write", "ucs2Write", "utf16leToBytes", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "ret", "out", "hexSliceLookupTable", "bytes", "newBuf", "checkOffset", "ext", "noAssert", "mul", "defineBigIntMethod", "validateNumber", "first", "last", "boundsError", "lo", "hi", "checkInt", "min", "maxBytes", "wrtBigUInt64LE", "checkIntBI", "wrtBigUInt64BE", "limit", "sub", "checkIEEE754", "writeFloat", "littleEndian", "writeDouble", "targetStart", "code", "errors", "E", "sym", "getMessage", "Base", "name", "range", "input", "msg", "received", "addNumericalSeparator", "checkBounds", "type", "INVALID_BASE64_RE", "base64clean", "units", "leadSurrogate", "byteArray", "c", "src", "dst", "alphabet", "table", "i16", "fn", "BufferBigIntNotDefined", "require_identifiers", "__commonJSMin", "exports", "module", "require_style", "__commonJSMin", "exports", "module", "require_transformers", "__commonJSMin", "exports", "Buffer", "NON_SHORTEST", "TRAILING", "RANGE", "ILL_FORMED", "mask", "ascii", "base64chars", "base64codes", "char", "chars", "bytes", "u", "buf", "bom", "bytes2", "b1", "b2", "x", "bytes3", "b3", "bytes4", "b4", "c", "i1", "i2", "i3", "inc", "len", "i", "TRUE", "at", "h", "l", "j", "high", "low", "str", "digit", "b", "isHex", "hex", "getx", "bufArg", "ret", "getu", "getU", "error", "CR", "LF", "lfchars", "tail", "units", "base64", "codes", "validate", "val", "n", "lineLen", "buildLine", "c1", "c2", "c3", "c4", "require_converter", "__commonJSMin", "exports", "Buffer", "trans", "UTF8", "UTF16", "UTF16BE", "UTF16LE", "UTF32", "UTF32BE", "UTF32LE", "UINT7", "ASCII", "BINARY", "UINT8", "UINT16", "UINT16LE", "UINT16BE", "UINT32", "UINT32LE", "UINT32BE", "ESCAPED", "STRING", "bom8", "src", "buf", "bom16", "bom32", "validateSrc", "type", "data", "getType", "typeArg", "ret", "result", "validateDst", "chars", "fix", "rem", "TRUE", "encode", "decode", "c", "dst", "convert", "srcType", "srcData", "dstType", "require_emitcss", "__commonJSMin", "exports", "module", "require_utilities", "__commonJSMin", "exports", "style", "converter", "emitCss", "id", "thisFileName", "getBounds", "length", "begArg", "len", "end", "beg", "TRUE", "html", "titleArg", "title", "page", "result", "caption", "cap", "success", "state", "chars", "phraseIndex", "phraseLength", "string", "type", "ret", "char", "ch", "bounds", "isUnicode", "i", "str", "require_ast", "__commonJSMin", "exports", "module", "id", "utils", "thisFileName", "that", "rules", "udts", "chars", "nodeCount", "nodesDefined", "nodeCallbacks", "stack", "records", "rulesIn", "udtsIn", "charsIn", "i", "list", "index", "lower", "callbackIndex", "name", "thisIndex", "phraseIndex", "phraseLength", "thatIndex", "data", "ret", "callback", "record", "length", "indent", "n", "modeArg", "display", "caption", "mode", "xml", "depth", "rec", "obj", "require_circular_buffer", "__commonJSMin", "exports", "module", "thisFileName", "itemIndex", "maxListSize", "size", "item", "fn", "i", "listIndex", "require_parser", "__commonJSMin", "exports", "module", "id", "utils", "thisFileName", "thisThis", "opExecute", "opcodes", "chars", "charsBegin", "charsLength", "charsEnd", "lookAround", "treeDepth", "maxTreeDepth", "nodeHits", "ruleCallbacks", "udtCallbacks", "rules", "udts", "syntaxData", "maxMatched", "limitTreeDepth", "limitNodeHits", "evaluateRule", "ruleIndex", "phraseIndex", "sysData", "functionName", "length", "evaluateUdt", "udtIndex", "clear", "backRef", "stack", "init", "obj", "rule", "udt", "copy", "top", "name", "lengthArg", "index", "systemData", "thisData", "lookAroundValue", "inLookAround", "inLookBehind", "initializeAst", "TRUE", "initializeTrace", "initializeStats", "initializeGrammar", "grammar", "initializeStartRule", "startRule", "start", "lower", "i", "initializeInputChars", "inputArg", "begArg", "lenArg", "input", "beg", "len", "initializeCallbacks", "func", "list", "depth", "hits", "privateParse", "startRuleArg", "callbackData", "success", "inputChars", "inputIndex", "inputLength", "opALT", "opIndex", "op", "opCAT", "astLength", "catCharIndex", "catPhrase", "ulen", "plen", "opREP", "repCharIndex", "repPhrase", "repCount", "validateRnmCallbackResult", "charsLeft", "down", "str", "opRNM", "astDefined", "savedOpcodes", "saveFrame", "callback", "notLookAround", "validateUdtCallbackResult", "opUDT", "astIndex", "opAND", "pop", "opNOT", "opTRG", "opTBS", "opTLS", "code", "opABG", "opAEN", "opBKR", "lmcode", "frame", "insensitive", "lmIndex", "opBKA", "opBKN", "opCATBehind", "catMatched", "opREPBehind", "opTRGBehind", "char", "opTBSBehind", "opTLSBehind", "opBKRBehind", "ret", "lk", "require_stats", "__commonJSMin", "exports", "module", "id", "utils", "style", "thisFileName", "rules", "udts", "stats", "totals", "ruleStats", "udtStats", "nameId", "sortAlpha", "lhs", "rhs", "sortHits", "sortIndex", "EmptyStat", "clear", "i", "incStat", "stat", "state", "displayRow", "name", "html", "displayOpsOnly", "displayRules", "ret", "inputRules", "inputUdts", "op", "result", "type", "caption", "test", "title", "require_trace", "__commonJSMin", "exports", "module", "utils", "style", "circular", "id", "thisFileName", "that", "MODE_HEX", "MODE_DEC", "MODE_ASCII", "MODE_UNICODE", "MAX_PHRASE", "MAX_TLS", "records", "maxRecords", "lastRecord", "filteredRecords", "treeDepth", "recordStack", "chars", "rules", "udts", "operatorFilter", "ruleFilter", "PHRASE_END", "PHRASE_CONTINUE", "PHRASE_EMPTY", "initOperatorFilter", "setOperators", "set", "items", "name", "upper", "initRuleFilter", "setRules", "count", "i", "list", "lower", "max", "last", "rulesIn", "udtsIn", "charsIn", "filterOps", "op", "ret", "filterRecords", "record", "state", "offset", "length", "anchor", "lookAround", "thisLine", "thatLine", "thatRecord", "toTreeObj", "nodeOpcode", "node", "opcode", "casetype", "modetype", "nodePhrase", "index", "nodeId", "nodeDown", "parent", "depth", "nodeUp", "leafNodes", "branchCount", "walk", "display", "obj", "c", "branch", "root", "firstRecord", "dummy", "lineIndex", "num", "prev", "branchesIncomplete", "stringify", "mode", "caption", "title", "htmlHeader", "modeName", "header", "htmlFooter", "footer", "html", "displayTrg", "hex", "displayRep", "displayTbs", "len", "displayTls", "charu", "charl", "base", "subPhrase", "charsArg", "phrase", "comma", "displayBehind", "beg1", "len1", "beg2", "len2", "lastchar", "spanBehind", "spanRemainder", "spanend", "displayForward", "spanAhead", "displayAhead", "displayNone", "htmlTable", "lookAhead", "lookBehind", "line", "modearg", "modein", "require_node_exports", "__commonJSMin", "exports", "module", "require_scanner_grammar", "__commonJSMin", "exports", "module", "str", "require_scanner_callbacks", "__commonJSMin", "exports", "ids", "utils", "semLine", "state", "chars", "phraseIndex", "phraseCount", "data", "semLineText", "semLastLine", "semInvalid", "semEnd", "semLF", "semCR", "semCRLF", "callbacks", "require_scanner", "__commonJSMin", "exports", "module", "chars", "errors", "strict", "trace", "thisFileName", "apglib", "grammar", "callbacks", "lines", "parser", "data", "require_syntax_callbacks", "__commonJSMin", "exports", "module", "thisFileName", "apglib", "id", "topAlt", "synFile", "result", "chars", "phraseIndex", "data", "synRule", "synRuleError", "synRuleNameError", "synDefinedAsError", "synAndOp", "synNotOp", "synBkaOp", "synBknOp", "synAbgOp", "synAenOp", "synBkrOp", "name", "synUdtOp", "synTlsOpen", "synTlsString", "synStringTab", "synTlsClose", "synClsOpen", "synClsString", "synClsClose", "synProsValOpen", "synProsValString", "synProsValClose", "synGroupOpen", "synGroupClose", "synOptionOpen", "synOptionClose", "synBasicElementError", "synLineEnd", "end", "synLineEndError", "synRepetition", "require_semantic_callbacks", "__commonJSMin", "exports", "module", "apglib", "id", "NameList", "name", "ret", "lower", "i", "decnum", "chars", "beg", "len", "num", "binnum", "hexnum", "digit", "semFile", "state", "phraseIndex", "phraseCount", "data", "nameObj", "rule", "op", "udt", "semRule", "semRuleLookup", "ruleName", "semAlternation", "semConcatenation", "semRepetition", "semOptionOpen", "semRuleName", "semDefined", "semIncAlt", "semRepOp", "semRepMin", "semRepMax", "semRepMinMax", "semAndOp", "semNotOp", "semRnmOp", "semAbgOp", "semAenOp", "semBkaOp", "semBknOp", "semBkrOp", "semBkrCi", "semBkrCs", "semBkrUm", "semBkrPm", "semBkrName", "semUdtEmpty", "udtName", "semUdtNonEmpty", "semTlsOp", "semTlsCase", "semTlsString", "str", "semClsOp", "semTbsOp", "semTrgOp", "semDmin", "semDmax", "semBmin", "semBmax", "semXmin", "semXmax", "semDstring", "semBstring", "semXstring", "require_sabnf_grammar", "__commonJSMin", "exports", "module", "str", "require_parser", "__commonJSMin", "exports", "module", "thisFileName", "ApgLib", "id", "syn", "sem", "sabnfGrammar", "parser", "findLine", "lines", "charIndex", "charLength", "i", "translateIndex", "map", "index", "ret", "reduceOpcodes", "rules", "rule", "opcodes", "reducedIndex", "op", "chars", "errors", "strict", "trace", "data", "udts", "name", "source", "bkrname", "bkrlower", "opcodeCount", "charCodeMin", "charCodeMax", "ruleNames", "udtNames", "alt", "cat", "rnm", "udt", "rep", "and", "not", "tls", "tbs", "trg", "bkr", "bka", "bkn", "abg", "aen", "udtFunc", "funcname", "ii", "thisRule", "thisUdt", "ruleIndex", "opIndex", "prefix", "str", "line", "end", "stringArg", "obj", "string", "require_rule_attributes", "__commonJSMin", "exports", "module", "id", "thisFile", "state", "isEmptyOnly", "attr", "isRecursive", "isCatNested", "attrs", "count", "i", "j", "k", "isCatCyclic", "isCatLeft", "isCatRight", "isCatEmpty", "isCatFinite", "cat", "stateArg", "opcodes", "opIndex", "iAttr", "opCat", "childAttrs", "opEval", "alt", "opAlt", "bkr", "opBkr", "ruleAttrsEval", "opi", "ruleIndex", "attri", "ruleAttributes", "temp", "truth", "val", "tError", "fError", "showAttr", "seq", "index", "dep", "str", "showLegend", "showAttributeErrors", "depi", "show", "type", "ii", "ruleIndexes", "order", "leader", "require_rule_dependencies", "__commonJSMin", "exports", "module", "id", "state", "scan", "ruleCount", "ruleDeps", "index", "isScanned", "i", "j", "rdi", "op", "opi", "ruleDependencies", "stateArg", "groupCount", "rdj", "newGroup", "show", "type", "count", "startSeg", "maxRule", "maxUdt", "lineLength", "str", "pre", "toArrow", "byArrow", "first", "ruleIndexes", "udtIndexes", "order", "require_attributes", "__commonJSMin", "exports", "module", "id", "ruleAttributes", "showAttributes", "showAttributeErrors", "ruleDependencies", "showRuleDependencies", "State", "rules", "udts", "i", "rule", "attr", "dst", "src", "ruleCount", "udtCount", "recursiveType", "length", "ret", "a", "left", "right", "lineMap", "errors", "state", "require_show_rules", "__commonJSMin", "exports", "module", "thisFileName", "rulesIn", "udtsIn", "order", "thisFuncName", "alphaArray", "udtAlphaArray", "indexArray", "udtIndexArray", "rules", "udts", "ruleCount", "udtCount", "str", "i", "compRulesAlpha", "left", "right", "compUdtsAlpha", "require_api", "__commonJSMin", "exports", "module", "src", "Buffer", "thisFileName", "thisObject", "apglib", "converter", "scanner", "parser", "attributes", "showAttributes", "showAttributeErrors", "showRuleDependencies", "showRules", "abnfToHtml", "chars", "beg", "len", "CONTROL_BEG", "CONTROL_END", "INVALID_BEG", "INVALID_END", "end", "html", "TRUE", "state", "i", "ch", "abnfToAscii", "str", "linesToAscii", "lines", "val", "linesToHtml", "errorsToHtml", "errors", "title", "style", "errorArrow", "line", "relchar", "text", "prefix", "suffix", "errorsToAscii", "error", "isScanned", "isParsed", "isTranslated", "haveAttributes", "attributeErrors", "lineMap", "strict", "trace", "ret", "order", "name", "require_valid_url", "__commonJSMin", "exports", "module", "is_iri", "is_http_iri", "is_https_iri", "is_web_iri", "splitUri", "uri", "splitted", "value", "scheme", "authority", "path", "query", "fragment", "out", "allowHttps", "port", "QUOTA", "BrowserRandomSource", "browserCrypto", "length", "out", "i", "exports", "wipe", "array", "i", "exports", "wipe_1", "NodeRandomSource", "__require", "nodeCrypto", "length", "buffer", "out", "i", "exports", "browser_1", "node_1", "SystemRandomSource", "length", "exports", "imulShim", "a", "b", "ah", "al", "bh", "bl", "exports", "add", "sub", "rotl", "x", "n", "rotr", "isIntegerShim", "int_1", "readInt16BE", "array", "offset", "exports", "readUint16BE", "readInt16LE", "readUint16LE", "writeUint16BE", "value", "out", "writeUint16LE", "readInt32BE", "readUint32BE", "readInt32LE", "readUint32LE", "writeUint32BE", "writeUint32LE", "readInt64BE", "hi", "lo", "readUint64BE", "readInt64LE", "readUint64LE", "writeUint64BE", "writeUint64LE", "readUintBE", "bitLength", "result", "mul", "readUintLE", "writeUintBE", "div", "writeUintLE", "readFloat32BE", "view", "readFloat32LE", "readFloat64BE", "readFloat64LE", "writeFloat32BE", "writeFloat32LE", "writeFloat64BE", "writeFloat64LE", "system_1", "binary_1", "wipe_1", "exports", "randomBytes", "length", "prng", "randomUint32", "buf", "result", "ALPHANUMERIC", "randomString", "charset", "out", "charsLen", "maxByte", "i", "randomByte", "randomStringForEntropy", "bits", "siwe_exports", "__export", "SiweError", "SiweErrorType", "SiweMessage", "VerifyOptsKeys", "VerifyParamsKeys", "checkContractWalletSignature", "checkInvalidKeys", "generateNonce", "isValidISO8601Date", "import_api", "import_node_exports", "number", "n", "bytes", "b", "lengths", "hash", "number", "exists", "instance", "checkFinished", "output", "out", "min", "U32_MASK64", "_32n", "fromBig", "n", "le", "split", "lst", "Ah", "Al", "i", "h", "l", "rotlSH", "h", "l", "s", "rotlSL", "rotlBH", "rotlBL", "crypto", "u8a", "a", "u32", "arr", "createView", "rotr", "word", "shift", "isLE", "hexes", "_", "i", "bytesToHex", "bytes", "u8a", "hex", "utf8ToBytes", "str", "toBytes", "data", "u8a", "concatBytes", "arrays", "r", "sum", "a", "pad", "Hash", "toStr", "wrapConstructor", "hashCons", "hashC", "msg", "toBytes", "tmp", "wrapXOFConstructorWithOpts", "hashCons", "hashC", "msg", "opts", "toBytes", "tmp", "randomBytes", "bytesLength", "crypto", "SHA3_PI", "SHA3_ROTL", "_SHA3_IOTA", "_0n", "_1n", "_2n", "_7n", "_256n", "_0x71n", "round", "R", "x", "y", "t", "j", "SHA3_IOTA_H", "SHA3_IOTA_L", "split", "rotlH", "h", "l", "s", "rotlBH", "rotlSH", "rotlL", "rotlBL", "rotlSL", "keccakP", "rounds", "B", "idx1", "idx0", "B0", "B1", "Th", "Tl", "curH", "curL", "shift", "PI", "Keccak", "_Keccak", "Hash", "blockLen", "suffix", "outputLen", "enableXOF", "number", "u32", "data", "exists", "state", "toBytes", "len", "pos", "take", "i", "out", "bytes", "bufferOut", "output", "to", "gen", "wrapConstructor", "sha3_224", "sha3_256", "sha3_384", "sha3_512", "keccak_224", "keccak_256", "keccak_384", "keccak_512", "genShake", "wrapXOFConstructorWithOpts", "opts", "shake128", "shake256", "isEIP55Address", "address", "lowerAddress", "hash", "bytesToHex", "keccak_256", "ret", "i", "parseIntegerNumber", "number", "parsed", "GRAMMAR", "_GrammarApi", "api", "apgApi", "GrammarApi", "ParsedMessage", "msg", "parser", "apgLib", "id", "domain", "state", "chars", "phraseIndex", "phraseLength", "data", "ret", "address", "statement", "uri", "version", "chainId", "parseIntegerNumber", "nonce", "issuedAt", "expirationTime", "notBefore", "requestId", "resources", "result", "elements", "key", "value", "isEIP55Address", "uri", "version", "checkType", "value", "type", "name", "types", "t", "error", "resolveProperties", "keys", "k", "accum", "v", "index", "defineProperties", "target", "values", "key", "stringify", "value", "HEX", "result", "i", "keys", "k", "isError", "error", "code", "isCallException", "makeError", "message", "info", "shortMessage", "details", "key", "version", "defineProperties", "assert", "check", "assertArgument", "name", "assertArgumentCount", "count", "expectedCount", "_normalizeForms", "accum", "form", "assertNormalize", "assertPrivate", "givenGuard", "guard", "className", "method", "operation", "_getBytes", "value", "name", "copy", "result", "offset", "assertArgument", "getBytes", "getBytesCopy", "isHexString", "length", "HexCharacters", "hexlify", "data", "bytes", "getBytes", "result", "i", "v", "concat", "datas", "d", "dataLength", "isHexString", "dataSlice", "start", "end", "assert", "zeroPad", "data", "length", "left", "bytes", "getBytes", "assert", "result", "hexlify", "zeroPadValue", "zeroPadBytes", "BN_0", "BN_1", "maxValue", "fromTwos", "_value", "_width", "value", "getUint", "width", "getNumber", "assert", "mask", "toTwos", "getBigInt", "limit", "_bits", "bits", "name", "assertArgument", "e", "result", "Nibbles", "toBigInt", "v", "toNumber", "toBeHex", "toBeArray", "hex", "i", "offset", "_listener", "EventPayload", "emitter", "listener", "filter", "__publicField", "__privateAdd", "__privateSet", "defineProperties", "__privateGet", "errorFunc", "reason", "offset", "bytes", "output", "badCodepoint", "assertArgument", "ignoreFunc", "replaceFunc", "Utf8ErrorFuncs", "getUtf8CodePoints", "_bytes", "onError", "getBytes", "result", "i", "c", "extraLength", "overlongMask", "res", "j", "nextChar", "toUtf8Bytes", "str", "form", "assertNormalize", "c2", "pair", "_toUtf8String", "codePoints", "codePoint", "toUtf8String", "WordSize", "Padding", "passProperties", "_guard", "throwError", "name", "error", "wrapped", "_names", "_Result", "args", "guard", "items", "names", "wrap", "__privateAdd", "item", "index", "nameCounts", "accum", "__privateSet", "target", "prop", "receiver", "getNumber", "value", "result", "__privateGet", "assert", "start", "end", "i", "callback", "thisArg", "keys", "Result", "getValue", "value", "bytes", "toBeArray", "assert", "WordSize", "getBytesCopy", "concat", "Padding", "Coder", "name", "type", "localName", "dynamic", "__publicField", "defineProperties", "message", "assertArgument", "_data", "_dataLength", "_writeData", "writeData_fn", "Writer", "__privateAdd", "__privateSet", "__privateGet", "writer", "__privateMethod", "paddingOffset", "offset", "data", "_offset", "_peekBytes", "peekBytes_fn", "_Reader", "allowLoose", "hexlify", "length", "loose", "toBigInt", "toNumber", "alignedLength", "Reader", "HMAC", "Hash", "hash", "_key", "key", "toBytes", "blockLen", "pad", "i", "buf", "exists", "out", "bytes", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "setBigUint64", "view", "byteOffset", "value", "isLE", "_32n", "_u32_max", "wh", "wl", "h", "SHA2", "Hash", "blockLen", "outputLen", "padOffset", "createView", "data", "exists", "buffer", "toBytes", "len", "pos", "take", "dataView", "out", "output", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "Chi", "a", "b", "c", "Maj", "SHA256_K", "IV", "SHA256_W", "SHA256", "SHA2", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "T2", "sha256", "wrapConstructor", "SHA256", "locked", "_keccak256", "data", "keccak_256", "__keccak256", "keccak256", "_data", "getBytes", "hexlify", "func", "utils_exports", "__export", "bitGet", "bitLen", "bitMask", "bitSet", "bytesToHex", "bytesToNumberBE", "bytesToNumberLE", "concatBytes", "createHmacDrbg", "ensureBytes", "equalBytes", "hexToBytes", "hexToNumber", "numberToBytesBE", "numberToBytesLE", "numberToHexUnpadded", "numberToVarBytesBE", "utf8ToBytes", "validateObject", "_0n", "_1n", "_2n", "u8a", "a", "hexes", "_", "i", "bytes", "hex", "num", "len", "array", "j", "hexByte", "byte", "n", "title", "expectedLength", "res", "e", "arrays", "r", "sum", "pad", "b1", "b2", "str", "pos", "value", "u8n", "data", "u8fr", "arr", "hashLen", "qByteLen", "hmacFn", "v", "k", "reset", "h", "b", "reseed", "seed", "gen", "out", "sl", "pred", "validatorFns", "val", "object", "validators", "optValidators", "checkField", "fieldName", "type", "isOptional", "checkVal", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow", "num", "power", "modulo", "res", "pow2", "x", "invert", "number", "y", "u", "v", "q", "r", "m", "n", "tonelliShanks", "P", "legendreC", "Q", "S", "Z", "p1div4", "Fp", "root", "Q1div2", "g", "t2", "ge", "FpSqrt", "c1", "n2", "nv", "i", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "f", "num", "power", "_0n", "_1n", "p", "d", "FpInvertBatch", "nums", "tmp", "lastMultiplied", "acc", "i", "inverted", "nLength", "n", "nBitLength", "_nBitLength", "nByteLength", "Field", "ORDER", "bitLen", "isLE", "redef", "_0n", "BITS", "BYTES", "sqrtP", "FpSqrt", "f", "bitMask", "_1n", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "lst", "FpInvertBatch", "a", "b", "c", "numberToBytesLE", "numberToBytesBE", "bytes", "bytesToNumberLE", "bytesToNumberBE", "getFieldBytesLength", "fieldOrder", "bitLength", "getMinHashLength", "length", "mapHashToField", "key", "isLE", "len", "fieldLen", "minLen", "num", "bytesToNumberBE", "bytesToNumberLE", "reduced", "mod", "_1n", "numberToBytesLE", "numberToBytesBE", "_0n", "_1n", "wNAF", "c", "bits", "constTimeNegate", "condition", "item", "neg", "opts", "W", "windows", "windowSize", "elm", "n", "p", "d", "points", "base", "window", "i", "precomputes", "f", "mask", "maxNumber", "shiftBy", "offset", "wbits", "offset1", "offset2", "cond1", "cond2", "P", "precomputesMap", "transform", "comp", "validateBasic", "curve", "validateField", "validateObject", "__spreadProps", "__spreadValues", "nLength", "validatePointOpts", "curve", "opts", "validateBasic", "validateObject", "endo", "Fp", "a", "__spreadValues", "b2n", "h2b", "utils_exports", "DER", "m", "data", "E", "len", "res", "hex", "l", "r", "sBytes", "s", "rBytesLeft", "sig", "slice", "h", "num", "shl", "rhl", "sl", "rl", "_0n", "_1n", "_2n", "_3n", "_4n", "weierstrassPoints", "CURVE", "toBytes", "_c", "point", "_isCompressed", "concatBytes", "fromBytes", "bytes", "tail", "x", "y", "weierstrassEquation", "b", "x2", "x3", "isWithinCurveOrder", "assertGE", "normPrivateKeyToScalar", "key", "lengths", "nByteLength", "wrapPrivateKey", "n", "bytesToHex", "bytesToNumberBE", "ensureBytes", "error", "mod", "pointPrecomputes", "assertPrjPoint", "other", "Point", "px", "py", "pz", "p", "is0", "i", "points", "toInv", "P", "privateKey", "windowSize", "left", "right", "X1", "Y1", "Z1", "X2", "Y2", "Z2", "U1", "U2", "b3", "X3", "Y3", "Z3", "t0", "t1", "t2", "t3", "t4", "t5", "wnaf", "comp", "I", "k1neg", "k1", "k2neg", "k2", "k1p", "k2p", "d", "scalar", "fake", "f1p", "f2p", "f", "Q", "G", "mul", "sum", "iz", "z", "ax", "ay", "zz", "cofactor", "isTorsionFree", "clearCofactor", "isCompressed", "_bits", "wNAF", "validateOpts", "weierstrass", "curveDef", "CURVE_ORDER", "compressedLen", "uncompressedLen", "isValidFieldElement", "modN", "invN", "invert", "__spreadProps", "cat", "head", "y2", "isYOdd", "numToNByteStr", "numberToBytesBE", "isBiggerThanHalfOrder", "number", "HALF", "normalizeS", "slcNum", "from", "to", "Signature", "recovery", "msgHash", "rec", "bits2int_modN", "radj", "prefix", "R", "ir", "u1", "u2", "hexToBytes", "utils", "length", "getMinHashLength", "mapHashToField", "getPublicKey", "isProbPub", "item", "arr", "str", "getSharedSecret", "privateA", "publicB", "bits2int", "delta", "ORDER_MASK", "bitMask", "int2octets", "prepSig", "defaultSigOpts", "k", "hash", "randomBytes", "lowS", "prehash", "ent", "h1int", "seedArgs", "e", "seed", "k2sig", "kBytes", "ik", "q", "normS", "defaultVerOpts", "sign", "privKey", "C", "createHmacDrbg", "verify", "signature", "publicKey", "_a", "sg", "_sig", "derError", "is", "getHash", "hash", "key", "msgs", "hmac", "concatBytes", "randomBytes", "createCurve", "curveDef", "defHash", "create", "weierstrass", "__spreadValues", "__spreadProps", "secp256k1P", "secp256k1N", "_1n", "_2n", "divNearest", "a", "b", "sqrtMod", "y", "P", "_3n", "_6n", "_11n", "_22n", "_23n", "_44n", "_88n", "b2", "b3", "b6", "pow2", "b9", "b11", "b22", "b44", "b88", "b176", "b220", "b223", "t1", "t2", "root", "Fp", "Field", "secp256k1", "createCurve", "k", "n", "a1", "b1", "a2", "POW_2_128", "c1", "c2", "k1", "mod", "k2", "k1neg", "k2neg", "sha256", "_0n", "Point", "secp256k1", "ZeroHash", "MessagePrefix", "BN_0", "BN_1", "BN_2", "BN_27", "BN_28", "BN_35", "_guard", "toUint256", "value", "zeroPadValue", "toBeArray", "_r", "_s", "_v", "_networkV", "_Signature", "guard", "r", "s", "v", "__privateAdd", "assertPrivate", "__privateSet", "__privateGet", "assertArgument", "dataLength", "hexlify", "_value", "getNumber", "yParityAndS", "getBytes", "concat", "clone", "networkV", "bv", "getBigInt", "chainId", "sig", "assertError", "check", "message", "ZeroHash", "bytes", "isHexString", "yParity", "result", "Signature", "_privateKey", "_SigningKey", "privateKey", "__privateAdd", "assertArgument", "dataLength", "__privateSet", "hexlify", "__privateGet", "digest", "sig", "secp256k1", "getBytesCopy", "Signature", "toBeHex", "other", "pubKey", "getBytes", "key", "compressed", "bytes", "pub", "point", "signature", "secpSig", "concat", "p0", "p1", "pub0", "pub1", "SigningKey", "BN_0", "BN_36", "getChecksumAddress", "address", "chars", "expanded", "i", "hashed", "getBytes", "keccak256", "ibanLookup", "safeDigits", "ibanChecksum", "c", "block", "checksum", "Base36", "result", "key", "fromBase36", "value", "getAddress", "assertArgument", "isAddressable", "value", "checkAddress", "target", "promise", "result", "assert", "assertArgument", "getAddress", "resolveAddress", "resolver", "isAddressable", "_gaurd", "n", "value", "width", "signed", "Typed", "b", "size", "_typedSymbol", "_options", "_Typed", "gaurd", "type", "options", "__publicField", "__privateAdd", "assertPrivate", "defineProperties", "__privateSet", "v", "__privateGet", "dynamic", "name", "AddressCoder", "Coder", "localName", "writer", "_value", "value", "Typed", "getAddress", "error", "reader", "toBeHex", "AnonymousCoder", "Coder", "coder", "__publicField", "writer", "value", "reader", "pack", "writer", "coders", "values", "arrayValues", "unique", "coder", "name", "assert", "assertArgument", "staticWriter", "Writer", "dynamicWriter", "updateFuncs", "index", "value", "dynamicOffset", "updateFunc", "baseOffset", "func", "length", "unpack", "reader", "keys", "baseReader", "offset", "offsetReader", "error", "isError", "Result", "ArrayCoder", "Coder", "localName", "type", "dynamic", "__publicField", "defineProperties", "defaultChild", "result", "i", "_value", "Typed", "count", "assertArgumentCount", "WordSize", "AnonymousCoder", "BooleanCoder", "Coder", "localName", "writer", "_value", "value", "Typed", "reader", "DynamicBytesCoder", "Coder", "type", "localName", "writer", "value", "getBytesCopy", "length", "reader", "BytesCoder", "hexlify", "FixedBytesCoder", "Coder", "size", "localName", "name", "__publicField", "defineProperties", "writer", "_value", "data", "getBytesCopy", "Typed", "reader", "hexlify", "Empty", "NullCoder", "Coder", "localName", "writer", "value", "reader", "BN_0", "BN_1", "BN_MAX_UINT256", "NumberCoder", "Coder", "size", "signed", "localName", "name", "__publicField", "defineProperties", "writer", "_value", "value", "getBigInt", "Typed", "maxUintValue", "mask", "WordSize", "bounds", "toTwos", "reader", "fromTwos", "StringCoder", "DynamicBytesCoder", "localName", "writer", "_value", "toUtf8Bytes", "Typed", "reader", "toUtf8String", "TupleCoder", "Coder", "coders", "localName", "dynamic", "types", "coder", "type", "__publicField", "defineProperties", "values", "uniqueNames", "accum", "name", "index", "writer", "_value", "value", "Typed", "pack", "reader", "unpack", "id", "value", "keccak256", "toUtf8Bytes", "accessSetify", "addr", "storageKeys", "getAddress", "storageKey", "index", "assertArgument", "isHexString", "accessListify", "value", "set", "result", "accum", "a", "b", "computeAddress", "key", "pubkey", "SigningKey", "getAddress", "keccak256", "recoverAddress", "digest", "signature", "hashMessage", "message", "toUtf8Bytes", "keccak256", "concat", "MessagePrefix", "verifyMessage", "sig", "digest", "recoverAddress", "setify", "items", "result", "k", "_kwVisibDeploy", "KwVisibDeploy", "_kwVisib", "KwVisib", "_kwTypes", "KwTypes", "_kwModifiers", "KwModifiers", "_kwOther", "_keywords", "Keywords", "SimpleTokens", "regexWhitespacePrefix", "regexNumberPrefix", "regexIdPrefix", "regexId", "regexType", "_offset", "_tokens", "_subTokenString", "subTokenString_fn", "_TokenString", "tokens", "__privateAdd", "__privateSet", "__privateGet", "allowed", "top", "type", "__privateMethod", "link", "__privateWrapper", "i", "token", "from", "to", "t", "TokenString", "lex", "text", "throwError", "message", "offset", "brackets", "commas", "cur", "match", "suffix", "value", "getNumber", "allowSingle", "set", "included", "key", "consumeName", "keyword", "consumeKeywords", "keywords", "consumeMutability", "modifiers", "consumeParams", "allowIndexed", "ParamType", "consumeGas", "getBigInt", "consumeEoi", "regexArrayType", "verifyBasicType", "assertArgument", "length", "size", "_guard", "internal", "ParamTypeInternal", "ErrorFragmentInternal", "EventFragmentInternal", "ConstructorFragmentInternal", "FallbackFragmentInternal", "FunctionFragmentInternal", "StructFragmentInternal", "_walkAsync", "walkAsync_fn", "_ParamType", "guard", "name", "baseType", "indexed", "components", "arrayLength", "arrayChildren", "__publicField", "assertPrivate", "defineProperties", "format", "c", "comp", "process", "_this", "v", "promises", "obj", "error", "comps", "bracket", "arrayMatch", "setValue", "childType", "index", "_a", "param", "Fragment", "_Fragment", "inputs", "e", "ConstructorFragment", "ErrorFragment", "EventFragment", "FallbackFragment", "FunctionFragment", "StructFragment", "assert", "NamedFragment", "joinParams", "params", "p", "_ErrorFragment", "id", "input", "_EventFragment", "anonymous", "_ConstructorFragment", "payable", "gas", "_FallbackFragment", "stateMutability", "errorObj", "topIsValid", "mutability", "outputs", "_FunctionFragment", "o", "_StructFragment", "PanicReasons", "paramTypeBytes", "paramTypeNumber", "defaultCoder", "getBuiltinCallException", "action", "tx", "data", "abiCoder", "message", "reason", "invocation", "revert", "bytes", "getBytes", "hexlify", "error", "code", "transaction", "getAddress", "makeError", "_getCoder", "getCoder_fn", "_AbiCoder", "__privateAdd", "types", "coders", "type", "__privateMethod", "ParamType", "TupleCoder", "values", "assertArgumentCount", "coder", "writer", "Writer", "loose", "Reader", "param", "ArrayCoder", "c", "AddressCoder", "BooleanCoder", "StringCoder", "BytesCoder", "NullCoder", "match", "size", "assertArgument", "NumberCoder", "FixedBytesCoder", "AbiCoder", "LogDescription", "fragment", "topic", "args", "__publicField", "name", "signature", "defineProperties", "TransactionDescription", "selector", "value", "ErrorDescription", "Indexed", "hash", "PanicReasons", "BuiltinErrors", "message", "code", "reason", "_errors", "_events", "_functions", "_abiCoder", "_getFunction", "getFunction_fn", "_getEvent", "getEvent_fn", "_Interface", "fragments", "__privateAdd", "abi", "__privateSet", "frags", "a", "Fragment", "error", "fallback", "receive", "index", "bucket", "assertArgument", "__privateGet", "ConstructorFragment", "minimal", "format", "f", "j", "AbiCoder", "key", "__privateMethod", "values", "callback", "names", "b", "i", "isHexString", "ErrorFragment", "matching", "matchStr", "m", "result", "params", "data", "dataSlice", "concat", "bytes", "getBytesCopy", "assert", "hexlify", "_data", "tx", "getBytes", "customPrefix", "ef", "e", "parsed", "topics", "encodeTopic", "param", "id", "keccak256", "toBeHex", "zeroPadBytes", "zeroPadValue", "dataTypes", "dataValues", "eventTopic", "indexed", "nonIndexed", "dynamic", "ParamType", "resultIndexed", "resultNonIndexed", "keys", "nonIndexedIndex", "indexedIndex", "Result", "getBigInt", "log", "hexData", "forceUnique", "lastValue", "valueLength", "allowOptions", "Typed", "inputs", "lastArg", "FunctionFragment", "EventFragment", "Interface", "BN_0", "getValue", "value", "toJson", "copyRequest", "req", "result", "hexlify", "bigIntKeys", "key", "getBigInt", "numberKeys", "getNumber", "accessListify", "_transactions", "Block", "block", "provider", "__publicField", "__privateAdd", "__privateSet", "tx", "TransactionResponse", "defineProperties", "getValue", "__privateGet", "txs", "assert", "baseFeePerGas", "difficulty", "extraData", "gasLimit", "gasUsed", "hash", "miner", "nonce", "number", "parentHash", "timestamp", "transactions", "toJson", "index", "indexOrHash", "v", "assertArgument", "createOrphanedBlockFilter", "Log", "log", "topics", "address", "blockHash", "blockNumber", "data", "removed", "transactionHash", "transactionIndex", "receipt", "createRemovedLogFilter", "_logs", "TransactionReceipt", "gasPrice", "BN_0", "to", "from", "contractAddress", "logsBloom", "logs", "status", "root", "createRemovedTransactionFilter", "other", "createReorderedTransactionFilter", "_startBlock", "_TransactionResponse", "type", "signature", "accessList", "resolveProperties", "_confirms", "_timeout", "confirms", "timeout", "startBlock", "nextScan", "stopScanning", "checkReplacement", "mined", "i", "reason", "checkReceipt", "resolve", "reject", "cancellers", "cancel", "c", "timer", "makeError", "txListener", "error", "replaceListener", "isError", "EventLog", "Log", "log", "iface", "fragment", "__publicField", "args", "defineProperties", "UndecodedEventLog", "error", "_iface", "ContractTransactionReceipt", "TransactionReceipt", "provider", "tx", "__privateAdd", "__privateSet", "__privateGet", "ContractTransactionResponse", "TransactionResponse", "confirms", "receipt", "ContractUnknownEventPayload", "EventPayload", "contract", "listener", "filter", "ContractEventPayload", "_log", "BN_0", "canCall", "value", "canEstimate", "canResolve", "canSend", "getResolver", "_filter", "PreparedTopicFilter", "contract", "fragment", "args", "__privateAdd", "__publicField", "defineProperties", "runner", "getRunner", "resolver", "__privateSet", "resolvedArgs", "param", "index", "type", "v", "resolveAddress", "__privateGet", "feature", "getProvider", "copyOverrides", "arg", "allowed", "_overrides", "Typed", "assertArgument", "overrides", "copyRequest", "resolveArgs", "_runner", "inputs", "buildWrappedFallback", "populateTransaction", "tx", "iface", "noValue", "getBigInt", "noData", "payable", "staticCall", "assert", "error", "isCallException", "send", "provider", "ContractTransactionResponse", "estimateGas", "method", "buildWrappedMethod", "key", "getFragment", "resolveProperties", "result", "staticCallResult", "buildWrappedEvent", "internal", "internalValues", "setInternal", "values", "getInternal", "isDeferred", "getSubInfo", "event", "topics", "topicHashify", "name", "isHexString", "e", "t", "items", "tag", "hasSub", "subs", "getSub", "operation", "addr", "sub", "filter", "listener", "log", "foundFragment", "_foundFragment", "emit", "ContractEventPayload", "ContractUnknownEventPayload", "starting", "started", "lastEmit", "_emit", "payloadFunc", "count", "once", "passArgs", "resultPromise", "passProperties", "_a", "_BaseContract", "target", "abi", "_deployTx", "isAddressable", "Interface", "addrPromise", "deployTx", "makeError", "filters", "prop", "receiver", "isError", "code", "resolve", "reject", "checkCode", "hash", "fromBlock", "toBlock", "address", "EventLog", "UndecodedEventLog", "Log", "total", "listeners", "stop", "CustomContract", "BaseContract", "_ContractBase", "Contract", "verifyMessage", "hashMessage", "getAddress", "VerifyParamsKeys", "VerifyOptsKeys", "SiweError", "type", "expected", "received", "SiweErrorType", "import_random", "EIP1271_ABI", "EIP1271_MAGICVALUE", "ISO8601", "checkContractWalletSignature", "message", "signature", "provider", "walletContract", "Contract", "hashedMessage", "hashMessage", "generateNonce", "nonce", "isValidISO8601Date", "inputDate", "inputMatch", "inputDateParsed", "parsedInputMatch", "checkInvalidKeys", "obj", "keys", "invalidKeys", "key", "SiweMessage", "param", "parsedMessage", "ParsedMessage", "parseIntegerNumber", "generateNonce", "header", "uriField", "prefix", "versionField", "chainField", "nonceField", "suffixArray", "expiryField", "x", "suffix", "message", "signature", "provider", "data", "error", "params", "opts", "resolve", "reject", "_a", "_b", "_c", "fail", "result", "invalidParams", "checkInvalidKeys", "VerifyParamsKeys", "invalidOpts", "VerifyOptsKeys", "domain", "nonce", "time", "SiweError", "checkTime", "expirationDate", "notBefore", "EIP4361Message", "e", "addr", "verifyMessage", "EIP1271Promise", "checkContractWalletSignature", "isValid", "res", "EIP1271Response", "fallbackResponse", "args", "isEIP55Address", "getAddress", "isValidISO8601Date"]
}
